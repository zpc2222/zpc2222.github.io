[{"content":"基于Hugo部署静态博客 `先给大家介绍下：\nhugo号称是The world’s fastest framework for building websites，是由go语言编写的，编译速度和运行速度都是杠杠的。不像hexo依赖于node.js，项目依赖模块多，hexo g生成网页也比较慢\n选择方面：\n静态博客框架jekyll、hexo和hugo三者 Hugo ：51.5k Github地址/官网地址/主题汇总1/主题汇总2/主题汇总3 Jekyll：42.6k Github地址/官网地址/主题汇总1/主题汇总2/主题汇总3 Hexo： 32.6k Github地址/官网地址/主题汇总 Hugo使用go语言是一种编译型语言，速度非常快，而Jekyll使用ruby编写，hexo使用nodejs编写 静态网站，hugo的next主题部署 Jekyll 有github支持，可以将markdown文件直接放到git仓库，github会自动生成网页文件。（Github一直是一个亲ruby的社区） Hexo提供了方便的部署命令，可以做到一条命令部署到github上。 Hugo的官方文档写的非常好，部署简洁。前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 因为种种原因，本人最早用的Jekyll，后来发现Hexo主题更多，但是文章多的时候都比较慢（静态博客，每次都是全量生成的）,Hugo完美解决了这个问题，唯一的劣势就是主题不太多，但是程序员嘛，能用就行了！\n下面开始正文\n安装hugo环境 Hugo的安装有很多方式，Install Hugo | Hugo (gohugo.io) ，根据个人喜好可以自行安装。\nReleases · gohugoio/hugo (github.com) 下载最新版本，建议下载最新的，hugo_extended_0.104.2_windows-amd64.zip 环境变量配置 下好之后找个空文件夹放了，比如我这里用的D:\\Program Files\\hugo 修改系统的环境变量，将hugo.exe所在文件夹添加到里面 输入 hugo version 正确显示版本即可。\n下载模板 克隆模板 git clone https://github.com/zpc2222/hugo-blog.git 修改配置项config.yml 这里不做详细解释，看里面直接修改就行了 运行 hugo serve -D\n-D表示草稿也要渲染，-serve表示启动一个本地服务器，即时渲染，方便修改。 hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production。 由于本地 development 环境的限制, 评论系统**, **CDN 和 fingerprint 不会在 development 环境下启用。 你可以使用 hugo serve -e production 命令来开启这些特性。 值得一提的是不论输入的是server还是serve都是一样的。\n在浏览器中前往它给出的 http://localhost:1313 就能看到你刚生成的博客了。\n当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.\n现在再输入指令\nhugo -D\n这会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上。\n确认无误后就要把它发到公网上了，这里采用 GitHub pages 进行部署（当然，也有很多种方法也能达成这一目的）\nGitHub pages部署 如果你是第一次使用 GitHub，请自行搜索如何配置，这里不做讲解！\n首先确保你有一个 GitHub 账号，然后新建一个仓库，名为yourname.github.io，注意，你应该保证这里的 your name 为你的 GitHub 账号名称！然后再进行以下步骤：\n1 2 3 4 5 6 7 cd public git init git remote add origin https://github.com/yourname/yourname.github.io.git #此URL可在你的repo中找到 git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master 自动推送脚本： 1 2 3 4 5 6 hugo -D cd public git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master pause GitHub自动构建： 点击Actions选择simple workflow，内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # This is a basic workflow to help you get started with Actions name: hugo-deploy-CI # Controls when the action will run. on: push # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # docs：https://github.com/peaceiris/actions-gh-pages deploy: runs-on: ubuntu-20.04 steps: - name: Git checkout uses: actions/checkout@v2 - name: Setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.104.0\u0026#39; extended: true - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: zpc2222/zpc2222.github.io # 修改为自己的地址 publish_dir: ./public keep_files: true publish_branch: master 值得注意的是在最后一条Deploy中应使用with而非env，应使用deploy_key而非其他的名字。但目前网上大部分教程都没提及这一点，甚至有的还错误地使用！（使用的我模板可以跳过这步，在工程里直接修改EXTERNAL_REPOSITORY后的路径即可）\n上面操作完成后，你会发现action还是会报错的，因为personal_token（个人令牌）你没有生成，需要在仓库内配置下，名字是PERSONAL_TOKEN，value则是个人令牌，最好不要设置有效期： 令牌如何生成，这里不做讲述 然后每次提交代码，本工程的定时任务，会将静态的页面自动发布到 youname.github.io功能内，这个工程会自动发布到gitpages。如果没有配置的，可以检查下分支是否正确，我默认配置的是master 圈红的注意。\n","permalink":"https://zpc2222.github.io/posts/blog/blog-github/","summary":"基于Hugo部署静态博客 `先给大家介绍下： hugo号称是The world’s fastest framework for building websites，是由go语言编写的，编译速度和运行速度","title":"github部署静态博客"},{"content":"仅以此篇文章来测试下在通过 Hugo 引擎来建站时，是否支持 Markdown 文件内容中所写的各种语法，并展示下实际的效果。\n标题样式 让我们从所有可能的标题开始，在 HTML 中 \u0026lt;h1\u0026gt;-\u0026lt;h6\u0026gt;元素分别表示六个不同级别的标题样式，其中 \u0026lt;h1\u0026gt; 为最大标题，\u0026lt;h6\u0026gt;为最小标题，效果如下：\n标题 1 标题 2 标题 3 标题 4 标题 5 标题 6 段落格式 根据 W3C 定义的 HTML5 规范，HTML 文档由元素和文本组成。每个元素的组成都由一个开始标记表示，例如： \u0026lt;body\u0026gt; ，和结束标记表示，例如： \u0026lt;/body\u0026gt; 。（某些开始标记和结束标记在某些情况下可以省略，并由其他标记暗示。） 元素可以具有属性，这些属性控制元素的工作方式。例如：超链接是使用 a 元素及其 href 属性形成的。\nMarkdown 语法 1 ![图像说明](图像地址) HTML IMG 标签 1 \u0026lt;img src=\u0026#34;图像地址\u0026#34; width=\u0026#34;宽度\u0026#34; height=\u0026#34;高度\u0026#34; /\u0026gt; SVG 格式 1 \u0026lt;svg\u0026gt;xxxxxx\u0026lt;/svg\u0026gt; 列表类型 有序列表 第一个元素 第二个元素 第三个元素 无序列表 列表元素 另一个元素 和其它元素 嵌套列表 借助 HTML 的 ul 元素来实现。\n第一项 第二项 第二项第一个子项目 第二项第二个子项目 第二项第二分项第一分项 第二项第二分项第二分项 第二项第二分项第三分项 第二项第三个子项目 第二项第三分项第一分项 第二项第三分项第二分项 第二项第三分项第三分项 第三项 自定义列表 通过 HTML 的 dl 元素还支持自定义列表（表格列表）。\nHugo 目录结构 assets config.toml content data theme static Hugo 模板 基础模板 列表模板 单页模板 块引用 blockquote 元素表示从另一个源引用的内容，可以选择引用必须在 footer 或 cite 元素中，也可以选择使用注释和缩写等行内更改。\n引用文本 这一行也是同样的引用 同样你也在 blockquote 中使用 Markdown 语法书写\n带有引文的 Blockquote 元素效果。\n我的目标不是赚大钱,是为了制造好的电脑。当我意识到我可以永远当工程师时，我才创办了这家公司。\n— 史蒂夫·沃兹尼亚克 根据 Mozilla 的网站记录，Firefox 1.0 于 2004 年发布，并取得了巨大成功。\n表格 表格并不算是 Markdown 的核心要素，但 Hugo 同样支持它。\nID 创建者 模型 年份 1 Honda Accord 2009 2 Toyota Camry 2012 3 Hyundai Elantra 2010 可以使用 : （英文格式冒号）来对表格内容进行对齐。\n表格 可以是 很酷 左对齐 居中 右对齐 左对齐 居中 右对齐 左对齐 居中 右对齐 同样也可以在表格中使用 Markdown 语法。\n表格 中 使用 Markdown 语法 斜体 粗体 中划线 代码块 Code 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其它元素： abbr、sub、sup、kbd等等 GIF 是位图图像格式。\nH2O\nC6H12O6\nXn + Yn = Zn\n按X获胜。或按CTRL+ALT+F显示 FPS 计数器。\n比特作为信息论中的信息单位，也被称为 shannon ，以信息论领域的创始人 Claude shannon 的名字命名。\n参考：\n来自 Mainroad 主题的 Basic Elements 内容 ","permalink":"https://zpc2222.github.io/posts/blog/markdown-syntax/","summary":"\u003cp\u003e仅以此篇文章来测试下在通过 \u003ccode\u003eHugo\u003c/code\u003e 引擎来建站时，是否支持 \u003ccode\u003eMarkdown\u003c/code\u003e 文件内容中所写的各种语法，并展示下实际的效果。\u003c/p\u003e","title":"Markdown 语法支持"},{"content":"关于 integrity 的错误 错误描述 在 Github Pages 上部署 Hugo 博客后，网站样式丢失，打开浏览器 F12 控制台可以发现错误：Failed to find a valid digest in the 'integrity' attribute for resource \u0026quot;xxx.css\u0026quot;, The resource has been blocked.。\n解决办法 我用的是 PaperMod 主题，发现很多人使用hugo用这个主题，都会有这个问题，大部分的说明就是资源被墙了，然后用CDN加速，但是那么复杂，咱也不会啊，还在还有另一种解决办法（我是解决了，别人不一定，可以做个参考）\n修改html 文件 给出的解决办法是将网站中代表每个模块首页的 index.html 文件里面的 integrity 属性的值置空，我试着将网站首页的 index.html 文件改了一下，确实可以解决问题。但这么多 index.html 文件，一个个手改，工作量太大，也会容易遗漏。另外，即便这次改好了，后面再次重新发布文章的时候，就又会将其覆盖，所以这个方法并不可行。\n修改基类 html 文件 后面倒是在 Satckoverflow 上发现了一个类似的问题。下面有人回复说是需要将 assets 文件夹下的 head.html 中的 integrity 的值置空，就可以一劳永逸了，以后每次发布文章也不用担心被覆盖。可是按照他的路径我并没找到该文件，经过一番试错，最后在 themes\\PaperMod\\layouts\\partials 文件夹下找到一个 head.html 文件，发现里面确实有 integrity=\u0026quot;{{ $stylesheet.Data.Integrity }}\u0026quot; 这么一句代码，把它改为 integrity=\u0026quot;\u0026quot; 然后重新发布，发现效果杠杠的~\n一个后端，搜了一天多前端的问题，虽然还是不懂，但是问题好歹解决了，网站正常访问了！\n","permalink":"https://zpc2222.github.io/posts/blog/blog-question/","summary":"关于 integrity 的错误 错误描述 在 Github Pages 上部署 Hugo 博客后，网站样式丢失，打开浏览器 F12 控制台可以发现错误：Failed to find a valid digest in the 'integrity' attribute for resource \u0026quot;xxx.css\u0026quot;, The resource has been bloc","title":"部署hugo问题"},{"content":"数字人民币支付 背景： 数字货币支付，是对接的建行熊猫支付，通过微信小程序，跳转至建行数字货币支付的小程序中，进行支付，唯一的不好，就是回调的地址是在建行写死的，这样导致测试与开发环境，都是同一个回调地址，调试起来不太方便！ 支付逻辑 后端：根据订单价格，商户号等，生成URL 小程序：根据将URL传入到建行指定的小程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 小程序跳转代码，其中appId是写死的，URL从接口中获取即可 toCNY(info) { uni.navigateToMiniProgram({ appId: \u0026#39;wx787d6b09da4e3a96\u0026#39;, path: \u0026#34;pages/home/home?time:\u0026#34; + new Date().getTime(), extraData: { URL: info, }, envVersion: \u0026#39;release\u0026#39;, success: (res) =\u0026gt; { console.log(\u0026#39;enter\u0026#39;); }, fail: (err) =\u0026gt; { console.log(\u0026#39;enter fail\u0026#39;); // toast.showError(\u0026#34;操作失败\u0026#34;) } }) }, 需要提前申请好商户信息，公钥需要完整的才能进行查询\n配置项 1 2 3 4 5 6 7 8 9 10 digital: pay: #数字支付配置项 ccb_host: https://ch5.dcep.ccb.com/CCBIS/ccbMain_XM #建行互联网熊猫支付 ccb_query_host: https://ch5.dcep.ccb.com/CCBIS/B2CMainPlat_00_PD_BEPAY #查询URL CCB_IBSVersion: V6 Mrch_url: https://ywc.yijiahe.com/oc-app/applets/pay/digital-callback MERCHANTID: 777000557324015 POSID: \u0026#39;068901420\u0026#39; BRANCHID: 322000000 PUB: 8ecf389dfbb9b061c8c6c3bf020111 #公钥 生成支付的URL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 OrderInfo orderInfo = Optional.ofNullable(orderInfoMapper.selectById(orderId)).orElseThrow(() -\u0026gt; new BizException(\u0026#34;A03000\u0026#34;, \u0026#34;订单不存在\u0026#34;)); log.info(\u0026#34;准备数字支付, orderid is {}\u0026#34;, orderId); if (orderInfo.getTotalPrice() == null) { throw new RuntimeException(\u0026#34;支付金额为空\u0026#34;); } MacParams macParams = new MacParams(); macParams.setMERCHANTID(cCBPayParams.getMERCHANTID()); macParams.setBRANCHID(cCBPayParams.getBRANCHID()); BigDecimal bigDecimal = new BigDecimal(orderInfo.getTotalPrice() / 100.00).setScale(2, RoundingMode.HALF_UP); macParams.setPAYMENT(bigDecimal.doubleValue()); macParams.setORDERID(orderId); macParams.setCURCODE(\u0026#34;01\u0026#34;); macParams.setREMARK1(orderInfo.getUserId().toString()); macParams.setPOSID(cCBPayParams.getPOSID()); macParams.setPUB(cCBPayParams.getPUB()); String md5Url = getFiledsInfo(macParams).substring(1); String mac = md5(md5Url); int i = md5Url.indexOf(\u0026#34;\u0026amp;PUB=\u0026#34;); //获取签名内容原串 String strSrc = md5Url.substring(0, i); //拼接请求串 String url = ccbHost + \u0026#34;?CCB_IBSVersion=\u0026#34; + CCBIBSVersion + \u0026#34;\u0026amp;\u0026#34; + strSrc + \u0026#34;\u0026amp;MAC=\u0026#34; + mac + \u0026#34;\u0026amp;Mrch_url=\u0026#34; + Mrch_url + \u0026#34;\u0026amp;TX_FLAG=3\u0026#34;; log.info(\u0026#34;sendUrl={}\u0026#34;, url); return url; 支付查询 根据订单号，查询是否支付成功，刷新支付记录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 String result = \u0026#34;\u0026#34;; OrderInfo orderInfo = xxx CCBQueryParams queryParams = new CCBQueryParams(); queryParams.setMERCHANTID(cCBPayParams.getMERCHANTID()); queryParams.setBRANCHID(cCBPayParams.getBRANCHID()); queryParams.setPOSID(cCBPayParams.getPOSID()); queryParams.setOrdr_ID(orderId.toString()); cCBPayParams.setSYS_TX_STATUS(\u0026#34;00\u0026#34;); String pub = cCBPayParams.getPUB(); String paramsUrl = getFiledsInfo(queryParams).substring(1); log.info(\u0026#34;paramsUrl={}\u0026#34;, paramsUrl); //执行加密操作 CCBPayUtil ccbPayUtil = new CCBPayUtil(); String ccbParam = ccbPayUtil.makeCCBParam(paramsUrl, pub); //拼接请求串 String url = ccbQueryHost + \u0026#34;?CCB_IBSVersion=\u0026#34; + CCBIBSVersion + \u0026#34;\u0026amp;\u0026#34; + paramsUrl + \u0026#34;\u0026amp;ccbParam=\u0026#34; + ccbParam; log.info(\u0026#34;sendUrl={}\u0026#34;, url); String data = HttpClients.post(url, new HashMap\u0026lt;\u0026gt;()); log.info(\u0026#34;receivedData={}\u0026#34;, data); CCBPayResult ccbPayResult = JSON.parseObject(data, CCBPayResult.class); if (ccbPayResult == null) { return \u0026#34;数字支付侧订单查询无支付结果,请稍后重试\u0026#34;; } BigDecimal bigDecimal = new BigDecimal(orderInfo.getTotalPrice() / 100.00).setScale(2, RoundingMode.HALF_UP); double amount = bigDecimal.doubleValue(); for (CCBPayResult.Detail_Grp grp : ccbPayResult.getDetail_Grp()) { if (grp.getORDERID().equals(orderId.toString()) \u0026amp;\u0026amp; grp.getSTATUSCODE().equals(\u0026#34;00\u0026#34;) \u0026amp;\u0026amp; grp.getAMOUNT().equals(amount)) { log.info(\u0026#34;数字支付订单回调成功\u0026#34;); orderService.updateOrderStatus(orderId, PAID, OrderInfoVO.builder().payMethod(DIGITAL.getCode()).build()); PayRecord payRecord = new PayRecord(); payRecord.setPayMerchantid(cCBPayParams.getMERCHANTID()); payRecord.setPayPrice(orderInfo.getTotalPrice()); payRecord.setOrderId(orderId); payRecord.setType(1); saveRecord(payRecord, 1); return \u0026#34;订单支付成功,支付记录已保存\u0026#34;; } } return ccbPayResult.toString(); 回调 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 if (!cCBPayParams.getPOSID().equals(result.getPOSID()) || !cCBPayParams.getBRANCHID().equals(result.getBRANCHID())) { log.info(\u0026#34;URL解析参数：{},非本公司商户信息\u0026#34;, result); throw new BizException(DIGITAL_POSID_ERROR); } //商户柜台完整公钥 String pubKey = \u0026#34;1234567\u0026#34;; String strSrc = \u0026#34;\u0026#34;; String sign = result.getSIGN(); try { int i = param.indexOf(\u0026#34;\u0026amp;SIGN=\u0026#34;); //获取签名内容原串 strSrc = param.substring(0, i); } catch (Exception e) { log.error(\u0026#34;签名内容原串获取失败\u0026#34;); } CCBPayUtil ccbPayUtil = new CCBPayUtil(); boolean isSign = ccbPayUtil.verifyNotifySign(strSrc, sign, pubKey); if (isSign) { Long orderId = Long.valueOf(result.getORDERID()); OrderInfo orderInfo = Optional.ofNullable(orderInfoMapper.selectById(orderId)).orElseThrow(() -\u0026gt; new BizException(\u0026#34;666\u0026#34;, \u0026#34;订单不存在\u0026#34;)); BigDecimal bigDecimal = new BigDecimal(orderInfo.getTotalPrice() / 100.00).setScale(2, RoundingMode.HALF_UP); if (result.getSUCCESS().equals(\u0026#34;Y\u0026#34;) \u0026amp;\u0026amp; result.getPAYMENT().equals(bigDecimal.toString())) { log.info(\u0026#34;数字支付订单回调成功\u0026#34;); orderService.updateOrderStatus(orderId, PAID, OrderInfoVO.builder().payMethod(DIGITAL.getCode()).build()); PayRecord payRecord = new PayRecord(); payRecord.setPayMerchantid(cCBPayParams.getMERCHANTID()); payRecord.setPayPrice(orderInfo.getTotalPrice()); payRecord.setOrderId(orderId); payRecord.setType(1); saveRecord(payRecord, 1); return \u0026#34;订单支付成功,支付记录已保存\u0026#34;; } else { log.error(\u0026#34;回调参数不匹配：{}\u0026#34;, result); } strSrc = \u0026#34;签名验证成功\u0026#34;; 当前只实现了支付，回调，查询功能，退款功能还未实现\n瓦片\u0026ndash;退款和对账 1.参数加密，接入sevlet地址，请求授权 2.获取授权结果，解析 \u0026ndash;得到token，通讯明文，ACC_ENTRY（商户地址） 3.退款参数加密，接入商户，发起退款请求\u0026mdash;\u0026gt;通讯明文对退款结果集解密\nFT_CORPID：调用方ID（FTC_sugwrobot） FT_TILEID：瓦片Id（07VMCX001） FT_SCENARIO：接口使用场景（sugwrobot）\n公钥pubKey1 =xxx 私钥priKey1 = xxx\n公钥pubKey2 = xxx\n/logs/nginx/oc.access.log 数字货币支付回调，nginx的日志：\n219.142.89.13 - - [13/Sep/2022:15:39:08 +0800] \u0026ldquo;POST /app/pay/digital-callback?POSID=123\u0026amp;BRANCHID=222\u0026amp;ORDERID=3333\u0026amp;PAYMENT=0.01\u0026amp;CURCODE=01\u0026amp;REMARK1=222\u0026amp;REMARK2=\u0026amp;ACC_TYPE=04\u0026amp;SUCCESS=Y\u0026amp;TYPE=1\u0026amp;REFERER=\u0026amp;CLIENTIP=1.1.1.1\u0026amp;SIGN=56e4a2ae874cc8fcfb98c4544aefc2855e621dbae9b94b43f5c5f12de7ba591fb0ed4cfce20b181f81af424e13dc535b7a560a3bdd3999a3c03b5cc121821e64e616a86342b73fb08be79f122928069933525dbee63b48b1904d6b5deb9486150c981c90d142d8e8130f292ec68bf8bd1feebf95f6136de30cf2cf1b7bf40724 HTTP/1.1\u0026rdquo; 200 80 \u0026ldquo;-\u0026rdquo; \u0026ldquo;Jakarta Commons-HttpClient/3.1\u0026rdquo;\n","permalink":"https://zpc2222.github.io/posts/tech/java/%E6%95%B0%E5%AD%97%E4%BA%BA%E6%B0%91%E5%B8%81%E6%94%AF%E4%BB%98/","summary":"数字人民币支付 背景： 数字货币支付，是对接的建行熊猫支付，通过微信小程序，跳转至建行数字货币支付的小程序中，进行支付，唯一的不好，就是回调的地","title":"数字人民币支付"},{"content":"登录框架 使用的spring security框架，通过过滤器进行拦截， 登录的时候通过jwt生成token 调用接口，携带token，同时刷新token时长 除了登录接口及 swagger，其他的都进行拦截\n过滤器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { private static final String[] EXCLUDE_URL = {\u0026#34;/doc.html\u0026#34;,\u0026#34;/app/login\u0026#34;}; /** * 认证失败处理类 */ private final AuthenticationEntryPointImpl unauthorizedHandler; private final JwtAccessDeniedHandler jwtAccessDeniedHandler; private final JwtAppletTokenUtils jwtUtil; public WebSecurityConfig(AuthenticationEntryPointImpl unauthorizedHandler, JwtAccessDeniedHandler jwtAccessDeniedHandler, JwtAppletTokenUtils jwtUtil) { this.unauthorizedHandler = unauthorizedHandler; this.jwtAccessDeniedHandler = jwtAccessDeniedHandler; this.jwtUtil = jwtUtil; } @Override protected void configure(HttpSecurity httpSecurity) throws Exception { httpSecurity // CSRF禁用，因为不使用session .csrf().disable() // 认证失败处理类 .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).accessDeniedHandler(jwtAccessDeniedHandler) // 防止iframe 造成跨域(这一段不写会导致swagger访问不了) .and().headers().frameOptions().disable().and() // 基于token，所以不需要session .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() // 过滤请求 .authorizeRequests() // 放行OPTIONS请求 .antMatchers(HttpMethod.OPTIONS, \u0026#34;/**\u0026#34;).permitAll() // 允许匿名访问接口 .antMatchers(EXCLUDE_URL).permitAll() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); httpSecurity.apply(new TokenConfigurer(jwtUtil)); } /*** * 核心过滤器配置方法 * @param web */ @Override public void configure(WebSecurity web) { web.ignoring().antMatchers(\u0026#34;/doc.html\u0026#34;, \u0026#34;/webjars/**\u0026#34;, \u0026#34;/**/api-docs/**\u0026#34;,\u0026#34;/login\u0026#34;,\u0026#34;/pay/callback\u0026#34;,\u0026#34;/pay/refundCallback\u0026#34;,\u0026#34;/pay/digital-callback\u0026#34;); } static class TokenConfigurer extends SecurityConfigurerAdapter\u0026lt;DefaultSecurityFilterChain, HttpSecurity\u0026gt; { private final JwtAppletTokenUtils jwtUtil; public TokenConfigurer(JwtAppletTokenUtils jwtUtil) { this.jwtUtil = jwtUtil; } @Override public void configure(HttpSecurity http) { JwtAuthenticationTokenFilter beforeFilter = new JwtAuthenticationTokenFilter(jwtUtil); http.addFilterBefore(beforeFilter, UsernamePasswordAuthenticationFilter.class); } } } Jwt 生成方法： 1 2 3 public String createToken(Map\u0026lt;String, Object\u0026gt; claims) { return Jwts.builder().claim(AUTHORITIES_KEY, JSONObject.toJSONString(claims)).setId(UUID.randomUUID().toString()).setIssuedAt(new Date()).setExpiration(new Date((new Date()).getTime() + tokenValidityInSeconds*1000)).compressWith(CompressionCodecs.DEFLATE).signWith(key, SignatureAlgorithm.HS512).compact(); } Jwt 校验方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public boolean validateToken(String authToken) { try { Date expiration = getExpirationDateFromToken(authToken); if (ObjectUtil.isNotNull(expiration) \u0026amp;\u0026amp; expiration.getTime() - System.currentTimeMillis() \u0026lt;= LAST_EXPIRE_TIME) { // 刷新过期时间 Claims claims = getClaimsFromToken(authToken); claims.setExpiration(new Date((new Date()).getTime() + tokenValidityInSeconds*1000)); } return true; } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) { log.error(\u0026#34;Invalid JWT signature.\u0026#34;, e); } catch (ExpiredJwtException e) { log.error(\u0026#34;Expired JWT token.\u0026#34;, e); } catch (UnsupportedJwtException e) { log.error(\u0026#34;Unsupported JWT token.\u0026#34;, e); } catch (IllegalArgumentException e) { log.error(\u0026#34;JWT token compact of handler are invalid.\u0026#34;, e); } return false; } public Date getExpirationDateFromToken(String token) { Date expiration; try { final Claims claims = getClaimsFromToken(token); expiration = claims.getExpiration(); } catch (Exception e) { expiration = null; } return expiration; } private Claims getClaimsFromToken(String token) { Claims claims; try { claims = Jwts.parser().setSigningKey(key).parseClaimsJws(token).getBody(); } catch (Exception e) { claims = null; } return claims; } ","permalink":"https://zpc2222.github.io/posts/tech/java/%E7%99%BB%E5%BD%95%E6%A1%86%E6%9E%B6/","summary":"登录框架 使用的spring security框架，通过过滤器进行拦截， 登录的时候通过jwt生成token 调用接口，携带token，同时刷新to","title":"登录框架"},{"content":"Git操作 命令 git push origin HEAD:refs/for/dev 推送到远端\n改日志： git rebase -i git commit \u0026ndash;amend -》修改里面日志信息，vim修改 git rebase \u0026ndash;continue 绑定本地分支与远端的分支，直接pull git branch \u0026ndash;set-upstream-to=origin/work work\n修改最新一次的提交 git rebase -i dev~1 pick修改为edit ，保存 git add . git rebase \u0026ndash;continue git push origin HEAD:refs/for/dev\ngit强制覆盖本地仓库 拉取所有更新，不同步； ``**git fetch --all** 本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)； git reset --hard origin/master 再更新一次（其实也可以不用，第二步命令做过了其实） git pull git fetch \u0026ndash;all \u0026amp;\u0026amp; git reset \u0026ndash;hard origin/master \u0026amp;\u0026amp; git pull\n问题 ssh：no matching host key type found. Their offer: ssh-dss\n在.ssh目录下创建config文件，并复制以下信息填入：\nHost * HostKeyAlgorithms +ssh-rsa PubkeyAcceptedKeyTypes +ssh-rsa KexAlgorithms +diffie-hellman-group1-sha1\n拉取问题 git github在内网环境设置代理访问报错： fatal: unable to access \u0026lsquo;https://github.com/XXX': Could not resolve host: github.com Unable to fetch in submodule path ‘XXX\u0026rsquo;\n$ git config \u0026ndash;global http.proxy 127.0.0.1:10809 $ git config \u0026ndash;global https.proxy https://10.xxx.xxx.xxx:1234 配置为代理，即可\n配置项 git config \u0026ndash;global user.email \u0026ldquo;gitHub邮箱\u0026rdquo;\ngit config \u0026ndash;global user.name \u0026ldquo;gitHub用户名\u0026rdquo;\ngit config\u0026ndash;global \u0026ndash;edit\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [alias] s= status br = branch co = checkout df = diff amend = commit --amend --no-edit cs = commit -s u= add -u pub = \u0026#34;!f() { git push origin HEAD:refs/for/$(gitrev-parse --abbrev-ref HEAD); }; f\u0026#34; sub = \u0026#34;!f() { git pull --rebase origin $(git rev-parse --abbrev-refHEAD); }; f\u0026#34; draft = \u0026#34;!f() { git push origin HEAD:refs/drafts/$(git rev-parse--abbrev-ref HEAD); }; f\u0026#34; [user] name=xxx email=xxx@163.com [core] editor=vi autocrlf=false safecrlf=false [commit] template=D:\\\\xxx.template [gui] encoding=utf-8 ","permalink":"https://zpc2222.github.io/posts/tools/git%E5%B8%B8%E7%94%A8/","summary":"Git操作 命令 git push origin HEAD:refs/for/dev 推送到远端 改日志： git rebase -i git commit \u0026ndash;amend -》修改里面日志信息，vim修改 git rebase \u0026ndash;continue 绑定本地分支与远端的分支，直接pull git branch \u0026ndash;set-upstream-to=origin/work work 修改","title":"Git常用"},{"content":" 插件名 功能 mybatisX 直接跳转到对面的xml中 Power Mode 忘了 Rainbow Brankets + 大括号明显 SequenceDiagram 接口流程图 GitToolBox git日志随时看 ","permalink":"https://zpc2222.github.io/posts/tools/idea/","summary":"插件名 功能 mybatisX 直接跳转到对面的xml中 Power Mode 忘了 Rainbow Brankets + 大括号明显 SequenceDiagram 接口流程图 GitToolBox git日志随时看","title":"IDEA"},{"content":"Shell： 添加用户 useradd -d /home/zpc -m zpc\n查看端口是否开放 /sbin/iptables -L -n\n开端口 firewall-cmd \u0026ndash;zone=public \u0026ndash;add-port=81/tcp \u0026ndash;permanent\n重启防火墙 systemctl restart firewalld.service\n查看端口 firewall-cmd \u0026ndash;list-ports\n安装JKD wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz\n安装jdk17\n/usr/lib/jvm/java-17-openjdk-amd64/\ntar -zxvf jdk-17_linux-x64_bin.tar.gz\nsudo mv jdk-17.0.1 /usr/local/\nsudo vim /etc/profile\nexport JAVA_HOME=/usr/local/jdk-17.0.1\nexport CLASSPATH=.:JAVA_HOME/lib\nexport PATH=.:JAVA_HOME/bin:$PATH\nsource /etc/profile\n","permalink":"https://zpc2222.github.io/posts/tools/linux/","summary":"Shell： 添加用户 useradd -d /home/zpc -m zpc 查看端口是否开放 /sbin/iptables -L -n 开端口 firewall-cmd \u0026ndash;zone=public \u0026ndash;add-port=81/tcp \u0026ndash;permanent 重启防火墙 systemctl restart firewalld.service 查看端口 firewall-cmd \u0026ndash;list-ports 安装JKD wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz 安装jdk17 /usr/lib/jvm/java-17-openjdk-amd64/ tar -zxvf jdk-17_linux-x64_bin.tar.gz sudo mv jdk-17.0.1 /usr/local/ sudo","title":"Linux"},{"content":"1、Markdown的编辑 1.1 新增md文件 开头要加上如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #标题 date: {{ .Date }} #创建时间 lastmod: {{ .Date }} #更新时间 author: [\u0026#34;Sulv\u0026#34;] #作者 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; #描述 weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true #是否展示评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; #图片路径：posts/tech/文章1/picture.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 1.1.1配置说明 首先修改 frontmatter 其中title表示文章标题， date为生成文章当时的时间， tags为标签， categories为目录， toc enable为启用文章目录（需要自己在文章中生成）， description为文章摘要， draft表示是否为草稿（写完了文章把这里改为 false 即可），\n为 LoveIt 主题的摘要标识符，该标识符上方的内容为文章摘要，如果上方为空，则采用 frontmatter 中设置的descriptions为文章摘要。\n写完了文章进行网页的构建\nhugo serve -D -e production\n-D表示草稿也要渲染，-serve表示启动一个本地服务器，即时渲染，方便修改。 hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production。 由于本地 development 环境的限制, 评论系统**, **CDN 和 fingerprint 不会在 development 环境下启用。 你可以使用 hugo serve -e production 命令来开启这些特性。 值得一提的是不论输入的是server还是serve都是一样的。\n在浏览器中前往它给出的 http://localhost:1313 就能看到你刚生成的博客了。\n当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.\n现在再输入指令\nhugo -D\n这会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上。\n确认无误后就要把它发到公网上了，这里采用 GitHub pages 进行部署（当然，也有很多种方法也能达成这一目的）\n1.2 GitHub pages部署 如果你是第一次使用 GitHub，请自行搜索如何配置，这里不做讲解！\n首先确保你有一个 GitHub 账号，然后新建一个仓库，名为yourname.github.io，注意，你应该保证这里的 your name 为你的 GitHub 账号名称！然后再进行以下步骤：\n1 2 3 4 5 6 7 cd public git init git remote add origin https://github.com/yourname/yourname.github.io.git #此URL可在你的repo中找到 git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master 1.2.3自动推送脚本： 1 2 3 4 5 6 hugo -D cd public git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master pause 1.2.3.1 GitHub自动构建： 点击Actions选择simple workflow，内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 name: CI #自动化的名称 on: push: # push的时候触发 branches: # 那些分支需要触发 - master jobs: build: runs-on: ubuntu-latest # 镜像市场 steps: - name: checkout # 步骤的名称 uses: actions/checkout@v2.3.4 #软件市场的名称 with: # 参数 submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2.4.13 with: hugo-version: 0.91.2 extended: true - name: Build run: hugo -D - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} EXTERNAL_REPOSITORY: xxx/xxx.github.io # 注意要修改本处地址 PUBLISH_BRANCH: master PUBLISH_DIR: ./public 值得注意的是在最后一条Deploy中应使用with而非env，应使用deploy_key而非其他的名字。但目前网上大部分教程都没提及这一点，甚至有的还错误地使用！\n","permalink":"https://zpc2222.github.io/posts/blog/blog-first/","summary":"\u003ch1 id=\"1markdown的编辑\"\u003e1、Markdown的编辑\u003c/h1\u003e\n\u003ch2 id=\"11-新增md文件\"\u003e1.1 新增md文件\u003c/h2\u003e\n\u003cp\u003e开头要加上如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e27\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e---\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitle: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #标题\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edate: {{ .Date }} #创建时间\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elastmod: {{ .Date }} #更新时间\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eauthor: [\u0026#34;Sulv\u0026#34;] #作者\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecategories: \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e- 分类1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e- 分类2\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etags: \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e- 标签1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e- 标签2\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edescription: \u0026#34;\u0026#34; #描述\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eweight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eslug: \u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edraft: false # 是否为草稿\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecomments: true #是否展示评论\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eshowToc: true # 显示目录\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTocOpen: true # 自动展开目录\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edisableShare: true # 底部不显示分享栏\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eshowbreadcrumbs: true #顶部显示当前路径\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecover:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    image: \u0026#34;\u0026#34; #图片路径：posts/tech/文章1/picture.png\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    caption: \u0026#34;\u0026#34; #图片底部描述\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    alt: \u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    relative: false\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e---\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"111配置说明\"\u003e1.1.1配置说明\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e首先修改 frontmatter\n其中title表示文章标题，\ndate为生成文章当时的时间，\ntags为标签，\ncategories为目录，\ntoc enable为启用文章目录（需要自己在文章中生成），\ndescription为文章摘要，\ndraft表示是否为草稿（写完了文章把这里改为 false 即可），\u003c/p\u003e\n\u003c/blockquote\u003e","title":"第一篇博客"},{"content":"Hugo文章里插入图片，我是用的图片url外链方式，MD里的写法是：\nHugo文章里插入视频，我用的B站外链短代码，这个短代码教程网上一搜就有了。\nHugo文章里插入音频，我还是用的url外链，写法：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200618103514921.png) https://blog.csdn.net/ds19991999/article/details/81293467\n写好了bilibili.html中，在markdown里嵌入视频的话，用以下形式写就ok了： \u003c!DOCTYPE HTML\u003e 如果需要指定part \u003c!DOCTYPE HTML\u003e ","permalink":"https://zpc2222.github.io/posts/blog/blog-music/","summary":"Hugo文章里插入图片，我是用的图片url外链方式，MD里的写法是： Hugo文章里插入视频，我用的B站外链短代码，这个短代码教程网上一搜就有","title":"视听"},{"content":"关于本站，及我\n本站： hugo发布的next主题的静态网站，个人使用过jekyll、hexo。最后发现了hugo这个宝藏！\nJekyll使用ruby编写，有github支持，可以将markdown文件直接放到git仓库，github会自动生成网页文件。（Github一直是一个亲ruby的社区） Hexo使用nodejs，提供了方便的部署命令，可以做到一条命令部署到github上。 Hugo使用go语言是一种编译型语言，速度非常快，官方文档写的非常好，部署简洁。前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 我： 一名Java程序员,爱研究，爱学习，爱探究新的技术！\n前三年：以前端的身份入职中软国际，未转正前转为测试，经理多个项目，从页面测试，黑盒测试，慢慢到后端及白盒测试 中三年：写了一年的testNG用例后，干脆还是做开发了，就这样又回到了开发岗位上，发现做技术，比打交道，要轻松的多了 后三年：正在进行中，学习新技术，学习架构中！ 网名: 藏锋 职业: 程序员 爱好: 溜达、爬山、养乌龟、种花草 联系方式 请看主页 ","permalink":"https://zpc2222.github.io/about/","summary":"关于本站，及我 本站： hugo发布的next主题的静态网站，个人使用过jekyll、hexo。最后发现了hugo这个宝藏！ Jekyll使用ru","title":"🙋🏻‍♂️关于"},{"content":"微信支付 框架为springboot，需要在小程序的后端服务中，使用接微信支付； 在网上选择了很多的技术选型，发现如果是自己封装，一个是太繁琐，还有就是不方便维护，发现一个比较好的springboot包。\n官网地址：‘Document (notfound403.github.io)’\nSpring boot依赖包 pom引用 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.felord\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;payment-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 导入之后，可以直接引用\n但是建议直接用别的依赖，如果人家停止维护了，还得重新搞一遍，可以学习下人家的源码，自己封装了下，对接微信支付V3的大部分SDK了\n源码地址 GitHub：GitHub - NotFound403/payment-spring-boot: 微信支付V3，微信优惠券，代金券、公众号支付、微信小程序支付、分账、支付分、商家券\n封装后引用与直接引用效果是一样的\n实现: 1. 预置条件 1.申请商户号 2.绑定小程序与商户号 3.在商户号里，生成V3的密钥（V1,V2不要用了，太老了） 4.下载p12证书，并导入到项目中` P12证书导入，编译可能不会成功，需要在pom里面加下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-resources\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-resources\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/maven-archiver/resources\u0026lt;/outputDirectory\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;/src/main/resources/profile-${profile.active}\u0026lt;/directory\u0026gt; \u0026lt;include\u0026gt;application.yml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;application-${profile.active}.yml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;log4j2-${profile.active}.xml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;bootstrap-${profile.active}.properties\u0026lt;/include\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;!-- 过滤后缀为pem、pfx的证书文件 --\u0026gt; \u0026lt;nonFilteredFileExtensions\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pem\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pfx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;p12\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;/nonFilteredFileExtensions\u0026gt; \u0026lt;/configuration\u0026gt;\u0026lt;/plugin\u0026gt; 2. 添加到工程的yaml配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 wechat: applets: # 小程序的配置项 openidUrl: https://api.weixin.qq.com/sns/jscode2session appid: appid secret: secret pay: #微信支付配置项 v3: # 微信小程序租户标识为 applets applets: # 应用appId 必填 app-id: appid # api v3 密钥 必填 app-v3-secret: v3secret # 微信支付商户号 必填 mch-id: 1234567 # 商户服务器域名 用于回调 回调路径为 domain + notifyUrl 需要放开回调接口的安全策略 必填 domain: https://xxx/app # 商户 api 证书路径 必填 填写classpath路径 位于 maven项目的resources文件下 cert-path: apiclient_cert.p12 3. 支付 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private final WechatApiProvider wechatApiProvider; OrderInfo orderInfo=XXx String ipAddr = getLocalIp(); // 定义附加数据 Map\u0026lt;String, Object\u0026gt; attach = new HashMap\u0026lt;\u0026gt;(); attach.put(\u0026#34;userId\u0026#34;, orderInfo.getUserId()); attach.put(\u0026#34;leaveComment\u0026#34;, orderInfo.getLeaveComment()); PayParams payParams = new PayParams(); // 商品描述,必填 payParams.setDescription(DESC); // 商户侧唯一订单号 建议为商户侧支付订单号 订单表主键 或者唯一标识字段 payParams.setOutTradeNo(orderInfo.getOrderId().toString()); payParams.setAttach(JSONObject.toJSONString(attach)); // 需要定义回调通知 payParams.setNotifyUrl(NOTIFY_URL); Amount amount = new Amount(); //付款金额单位为“分” amount.setTotal(orderInfo.getTotalPrice().intValue()); payParams.setAmount(amount); // 此类支付Payer必传,且openid需要同appid有绑定关系 具体去看文档 Payer payer = new Payer(); payer.setOpenid(openId); payParams.setPayer(payer); //支付场景描述 SceneInfo sceneInfo = new SceneInfo(); //用户终端IP sceneInfo.setPayerClientIp(ipAddr); if (orderInfo.getChargePileId() != null) { sceneInfo.setDeviceId(orderInfo.getChargePileId().toString()); } payParams.setSceneInfo(sceneInfo); wechatApiProvider.directPayApi(TENANT_ID).jsPay(payParams).getBody(); 4.支付回调： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 wechatApiProvider.callback(TENANT_ID).transactionCallback(params, data -\u0026gt; { Long orderId = Long.valueOf(data.getOutTradeNo()); OrderInfo orderInfo = orderInfoMapper.selectById(orderId); if (orderInfo == null) { log.error(\u0026#34;订单不存在，回调异常\u0026#34;); } if (UNPAID.getCode() != orderInfo.getStatus()) { log.error(\u0026#34;订单状态为[{}]，非未支付，回调异常\u0026#34;, orderInfo.getStatus()); } orderService.updateOrderStatus(orderId, PAID, OrderInfoVO.builder().payMethod(WXPAY.getCode()).build()); log.info(\u0026#34;订单状态刷新：orderId={}\u0026#34;, orderId); PayRecord payRecord = new PayRecord(); payRecord.setPayMerchantid(data.getMchid()); payRecord.setPayPrice(data.getAmount().getTotal()); payRecord.setOrderId(orderId); payRecord.setType(1); saveRecord(payRecord, 1); log.info(\u0026#34;支付记录保存：{}\u0026#34;, payRecord); }); 5.退款： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 RefundParams refundParams = new RefundParams(); RefundParams.RefundAmount amount = new RefundParams.RefundAmount(); amount.setRefund(paymentRefund.getRefundAmount()); amount.setTotal(paymentRefund.getActualAmount()); refundParams.setAmount(amount); refundParams.setOutRefundNo(REFUND + paymentRefund.getOutTradeNo()); refundParams.setNotifyUrl(NOTIFY_REFUND_URL); refundParams.setOutTradeNo(paymentRefund.getOutTradeNo()); refundParams.setReason(paymentRefund.getReason()); List\u0026lt;RefundGoodsDetail\u0026gt; goodsDetail = new ArrayList\u0026lt;\u0026gt;(); RefundGoodsDetail detail = new RefundGoodsDetail(); detail.setMerchantGoodsId(paymentRefund.getMerchantGoodsId()); detail.setGoodsName(paymentRefund.getGoodsName()); //数量写死1，商品单价金额等于总退款金额 detail.setUnitPrice(paymentRefund.getRefundAmount()); detail.setRefundQuantity(1); detail.setRefundAmount(paymentRefund.getRefundAmount()); goodsDetail.add(detail); refundParams.setGoodsDetail(goodsDetail); wechatApiProvider.directPayApi(TENANT_ID).refund(refundParams).getBody(); 6.退款回调: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 wechatApiProvider.callback(TENANT_ID).refundCallback(params, data -\u0026gt; { log.info(\u0026#34;退款回调：data={}\u0026#34;, data); Long orderId = Long.valueOf(data.getOutTradeNo()); OrderInfo orderInfo = orderInfoMapper.selectById(orderId); if (orderInfo == null) { log.error(\u0026#34;订单[{}]不存在，退款回调异常\u0026#34;, orderId); } if (PAID.getCode() != orderInfo.getStatus()) { log.error(\u0026#34;订单[{}]状态为[{}]，非已支付，请检查订单状态是否准确\u0026#34;, orderId, orderInfo.getStatus()); return; } orderService.updateOrderStatus(orderId, Constant.OrderStatus.REFUNDED, OrderInfoVO.builder().payMethod(WXPAY.getCode()).build()); log.info(\u0026#34;订单状态刷新：orderId={}\u0026#34;, orderId); PayRecord payRecord = new PayRecord(); payRecord.setPayMerchantid(data.getMchid()); payRecord.setPayPrice(data.getAmount().getPayerRefund()); payRecord.setOrderId(orderId); payRecord.setType(2); saveRecord(payRecord, 2); log.info(\u0026#34;支付记录保存：{}\u0026#34;, payRecord); }); 如上包含了基本支付的一套流程了，还有其他如账单下载，订单查询，关闭订单，积分支付，合并支付等复杂的接口，可以自己研究，封装类里面都已经包含了\n","permalink":"https://zpc2222.github.io/posts/tech/java/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/","summary":"微信支付 框架为springboot，需要在小程序的后端服务中，使用接微信支付； 在网上选择了很多的技术选型，发现如果是自己封装，一个是太繁琐，","title":"springboot接入微信支付"},{"content":"微信小程序相关 小程序地址\n1.登陆 获取openid方法，通过页面获取的jsCode，加上appid，秘钥，通过get方式获取\n1 2 3 4 5 6 7 8 OPENID_URL=\u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;; Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(8); map.put(\u0026#34;appid\u0026#34;, APPID); map.put(\u0026#34;secret\u0026#34;, SECRET); map.put(\u0026#34;js_code\u0026#34;, wechatUser.getJsCode()); map.put(\u0026#34;grant_type\u0026#34;, \u0026#34;authorization_code\u0026#34;); String resultJson = HttpClients.get(OPENID_URL, map); accessToken获取方法： 也是通过get方法，url不同,获取得到access_token跟expires_in（2小时默认）\n1 2 String url = TOKEN_URL + \u0026#34;?grant_type=client_credential\u0026amp;appid=\u0026#34; + APP_ID + \u0026#34;\u0026amp;secret=\u0026#34; + APP_SECRET; String resultJson = HttpClients.get(url) 3.订阅消息 接口说明： subscribeMessage.send | 微信开放文档 (qq.com)\n前提： 登陆小程序，创建好模板 获取模板id，字段\ndata中的类型，都以String类型存进去\nJava实现，具体字段参考上面的文档：\n1 2 3 4 String SUBSCRIBE_URL = \u0026#34;https://api.weixin.qq.com/cgi-bin/message/subscribe/send\u0026#34;; String url = SUBSCRIBE_URL + \u0026#34;?access_token=\u0026#34; + token; RequestBody body = RequestBody.create(JSON, Jsons.toJson(subMsg)); String resultJson = HttpClients.post(url, body); 可以用postman发送如下的，进行验证(access_token需要替换，touser必须要是该apiiid下生成的，并且已经在小程序端订阅了消息)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 post发送模板 https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=60_1LE2Afo9K2mvUGh-Oe_SKxKrA8_8HGKZhdg1wgtOj0oq_TI07E883H4ddCqkwtSn53OsKI4gqvj0YIle0RdwE_dwjy-ttci6nuDkH7Ja0zbJmsBa_FL-6lgtYsRZef9fWrNEF5-YgcsIPnd8KALiAGAYOZ { \u0026#34;touser\u0026#34;: \u0026#34;oEeL85FWxlG4HJU2eShtLMtWivoM\u0026#34;, \u0026#34;template_id\u0026#34;: \u0026#34;dgiozsRsVCqppuesQHJV5NZW5inmHf5bcNH5C74rglE\u0026#34;, \u0026#34;page\u0026#34;:\u0026#34;/pages/login/index\u0026#34;, \u0026#34;lang\u0026#34;:\u0026#34;zh_CN\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;character_string5\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;12312312333\u0026#34; }, \u0026#34;number13\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;11\u0026#34; }, \u0026#34;amount6\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;66\u0026#34; } , \u0026#34;time3\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;2022年08月22日\u0026#34; }, \u0026#34;thing7\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;充电结束啦\u0026#34; } } } ","permalink":"https://zpc2222.github.io/posts/tech/java/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3/","summary":"微信小程序相关 小程序地址 1.登陆 获取openid方法，通过页面获取的jsCode，加上appid，秘钥，通过get方式获取 1 2 3 4 5 6 7 8 OPENID_URL=\u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;;","title":"微信小程序相关"},{"content":"","permalink":"https://zpc2222.github.io/posts/life/life/","summary":"","title":"生活"},{"content":"","permalink":"https://zpc2222.github.io/posts/read/read/","summary":"","title":"阅读"},{"content":"cron表达式 （cron = \u0026ldquo;* * * * * *\u0026rdquo;)\ncron表达式格式： {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}\n例 \u0026ldquo;0 0 12 ? * WED\u0026rdquo; 在每星期三下午12:00 执行（年份通常 省略）\n*/5 * * * * ? 每隔5秒执行一次 0 */1 * * * ? 每隔1分钟执行一次 0 0 5-15 * * ? 每天5-15点整点触发 0 0/3 * * * ? 每三分钟触发一次 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点\n0 0 12 ? * WED 表示每个星期三中午12点 0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 0 23 L * ? 每月最后一天23点执行一次 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 * * ? 2005 2005年的每天上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发\n\u0026ldquo;30 * * * * ?\u0026rdquo; 每半分钟触发任务 \u0026ldquo;30 10 * * * ?\u0026rdquo; 每小时的10分30秒触发任务 \u0026ldquo;30 10 1 * * ?\u0026rdquo; 每天1点10分30秒触发任务 \u0026ldquo;30 10 1 20 * ?\u0026rdquo; 每月20号1点10分30秒触发任务 \u0026ldquo;30 10 1 20 10 ? *\u0026rdquo; 每年10月20号1点10分30秒触发任务 \u0026ldquo;30 10 1 20 10 ? 2011\u0026rdquo; 2011年10月20号1点10分30秒触发任务 \u0026ldquo;30 10 1 ? 10 * 2011\u0026rdquo; 2011年10月每天1点10分30秒触发任务 \u0026ldquo;30 10 1 ? 10 SUN 2011\u0026rdquo; 2011年10月每周日1点10分30秒触发任务 \u0026ldquo;15,30,45 * * * * ?\u0026rdquo; 每15秒，30秒，45秒时触发任务 \u0026ldquo;15-45 * * * * ?\u0026rdquo; 15到45秒内，每秒都触发任务 \u0026ldquo;15/5 * * * * ?\u0026rdquo; 每分钟的每15秒开始触发，每隔5秒触发一次 \u0026ldquo;15-30/5 * * * * ?\u0026rdquo; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次 \u0026ldquo;0 0/3 * * * ?\u0026rdquo; 每小时的第0分0秒开始，每三分钟触发一次 \u0026ldquo;0 15 10 ? * MON-FRI\u0026rdquo; 星期一到星期五的10点15分0秒触发任务 \u0026ldquo;0 15 10 L * ?\u0026rdquo; 每个月最后一天的10点15分0秒触发任务 \u0026ldquo;0 15 10 LW * ?\u0026rdquo; 每个月最后一个工作日的10点15分0秒触发任务 \u0026ldquo;0 15 10 ? * 5L\u0026rdquo; 每个月最后一个星期四的10点15分0秒触发任务 \u0026ldquo;0 15 10 ? * 5#3\u0026rdquo; 每个月第三周的星期四的10点15分0秒触发任务\n","permalink":"https://zpc2222.github.io/posts/tech/cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"cron表达式 （cron = \u0026ldquo;* * * * * *\u0026rdquo;) cron表达式格式： {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 例 \u0026ldquo;0 0 12 ? * WED\u0026rdquo; 在","title":"cron表达式"},{"content":"IP查询的一些方法 IP_URL = \u0026ldquo;http://whois.pconline.com.cn/ipJson.jsp?ip=%s\u0026amp;json=true\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 /** * 获取ip地址 */ public static String getIp(HttpServletRequest request) { String ip = request.getHeader(\u0026#34;x-forwarded-for\u0026#34;); if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;WL-Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) { ip = request.getRemoteAddr(); } String comma = \u0026#34;,\u0026#34;; String localhost = \u0026#34;127.0.0.1\u0026#34;; if (ip.contains(comma)) { ip = ip.split(\u0026#34;,\u0026#34;)[0]; } if (localhost.equals(ip)) { // 获取本机真正的ip地址 try { ip = InetAddress.getLocalHost().getHostAddress(); } catch (UnknownHostException e) { e.printStackTrace(); } } return ip; } /** * 根据ip获取详细地址 */ public static String getCityInfo(String ip) { String api = String.format(IP_URL, ip); JSONObject object = JSONUtil.parseObj(HttpUtil.get(api)); return object.get(\u0026#34;addr\u0026#34;, String.class); } /** * 获得当天是周几 */ public static String getWeekDay() { String[] weekDays = {\u0026#34;Sun\u0026#34;, \u0026#34;Mon\u0026#34;, \u0026#34;Tue\u0026#34;, \u0026#34;Wed\u0026#34;, \u0026#34;Thu\u0026#34;, \u0026#34;Fri\u0026#34;, \u0026#34;Sat\u0026#34;}; Calendar cal = Calendar.getInstance(); cal.setTime(new Date()); int w = cal.get(Calendar.DAY_OF_WEEK) - 1; if (w \u0026lt; 0) { w = 0; } return weekDays[w]; } public static String getBrowser(HttpServletRequest request) { UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\u0026#34;User-Agent\u0026#34;)); Browser browser = userAgent.getBrowser(); return browser.getName(); } /** * 导出excel */public static void downloadExcel(List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list, HttpServletResponse response) throws IOException { String tempPath = System.getProperty(\u0026#34;java.io.tmpdir\u0026#34;) + IdUtil.fastSimpleUUID() + \u0026#34;.xlsx\u0026#34;; File file = new File(tempPath); BigExcelWriter writer = ExcelUtil.getBigWriter(file); // 一次性写出内容，使用默认样式，强制输出标题 writer.write(list, true); //response为HttpServletResponse对象 response.setContentType(\u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8\u0026#34;); //test.xls是弹出下载对话框的文件名，不能为中文，中文请自行编码 response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=file.xlsx\u0026#34;); ServletOutputStream out = response.getOutputStream(); // 终止后删除临时文件 file.deleteOnExit(); writer.flush(out, true); //此处记得关闭输出Servlet流 IoUtil.close(out); } /** * 将文件名解析成文件的上传路径 */ public static File upload(MultipartFile file, String filePath) { String suffix = getExtensionName(file.getOriginalFilename()); StringBuffer nowStr = fileRename(); try { String fileName = nowStr + \u0026#34;.\u0026#34; + suffix; String path = filePath + fileName; // getCanonicalFile 可解析正确各种路径 File dest = new File(path).getCanonicalFile(); // 检测是否存在目录 if (!dest.getParentFile().exists()) { dest.getParentFile().mkdirs(); } // 文件写入 file.transferTo(dest); return dest; } catch (Exception e) { e.printStackTrace(); } return null; } /** * MultipartFile转File */public static File toFile(MultipartFile multipartFile) { // 获取文件名 String fileName = multipartFile.getOriginalFilename(); // 获取文件后缀 String prefix = \u0026#34;.\u0026#34; + getExtensionName(fileName); File file = null; try { // 用uuid作为文件名，防止生成的临时文件重复 file = File.createTempFile(IdUtil.simpleUUID(), prefix); // MultipartFile to File multipartFile.transferTo(file); } catch (IOException e) { e.printStackTrace(); } return file; } /** * 获取文件扩展名，不带 . */public static String getExtensionName(String filename) { if ((filename != null) \u0026amp;\u0026amp; (filename.length() \u0026gt; 0)) { int dot = filename.lastIndexOf(\u0026#39;.\u0026#39;); if ((dot \u0026gt; -1) \u0026amp;\u0026amp; (dot \u0026lt; (filename.length() - 1))) { return filename.substring(dot + 1); } } return filename; } public static String getFileType(String type) { String documents = \u0026#34;txt doc pdf ppt pps xlsx xls docx\u0026#34;; String music = \u0026#34;mp3 wav wma mpa ram ra aac aif m4a\u0026#34;; String video = \u0026#34;avi mpg mpe mpeg asf wmv mov qt rm mp4 flv m4v webm ogv ogg\u0026#34;; String image = \u0026#34;bmp dib pcp dif wmf gif jpg tif eps psd cdr iff tga pcd mpt png jpeg\u0026#34;; if (image.contains(type)) { return \u0026#34;pic\u0026#34;; } else if (documents.contains(type)) { return \u0026#34;txt\u0026#34;; } else if (music.contains(type)) { return \u0026#34;music\u0026#34;; } else if (video.contains(type)) { return \u0026#34;vedio\u0026#34;; } else { return \u0026#34;other\u0026#34;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 package com.ruoyi.common.core.utils.ip; import java.net.InetAddress; import java.net.UnknownHostException; import javax.servlet.http.HttpServletRequest; import com.ruoyi.common.core.utils.StringUtils; /** * 获取IP方法 * * @author zpc */public class IpUtils { /** * 获取客户端IP ** @param request 请求对象 * @return IP地址 */ public static String getIpAddr(HttpServletRequest request) { if (request == null) { return \u0026#34;unknown\u0026#34;; } String ip = request.getHeader(\u0026#34;x-forwarded-for\u0026#34;); if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;X-Forwarded-For\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;WL-Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;X-Real-IP\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getRemoteAddr(); } return \u0026#34;0:0:0:0:0:0:0:1\u0026#34;.equals(ip) ? \u0026#34;127.0.0.1\u0026#34; : getMultistageReverseProxyIp(ip); } /** * 检查是否为内部IP地址 * * @param ip IP地址 * @return 结果 */ public static boolean internalIp(String ip) { byte[] addr = textToNumericFormatV4(ip); return internalIp(addr) || \u0026#34;127.0.0.1\u0026#34;.equals(ip); } /** * 检查是否为内部IP地址 * * @param addr byte地址 * @return 结果 */ private static boolean internalIp(byte[] addr) { if (StringUtils.isNull(addr) || addr.length \u0026lt; 2) { return true; } final byte b0 = addr[0]; final byte b1 = addr[1]; // 10.x.x.x/8 final byte SECTION_1 = 0x0A; // 172.16.x.x/12 final byte SECTION_2 = (byte) 0xAC; final byte SECTION_3 = (byte) 0x10; final byte SECTION_4 = (byte) 0x1F; // 192.168.x.x/16 final byte SECTION_5 = (byte) 0xC0; final byte SECTION_6 = (byte) 0xA8; switch (b0) { case SECTION_1: return true; case SECTION_2: if (b1 \u0026gt;= SECTION_3 \u0026amp;\u0026amp; b1 \u0026lt;= SECTION_4) { return true; } case SECTION_5: switch (b1) { case SECTION_6: return true; } default: return false; } } /** * 将IPv4地址转换成字节 * * @param text IPv4地址 * @return byte 字节 */ public static byte[] textToNumericFormatV4(String text) { if (text.length() == 0) { return null; } byte[] bytes = new byte[4]; String[] elements = text.split(\u0026#34;\\\\.\u0026#34;, -1); try { long l; int i; switch (elements.length) { case 1: l = Long.parseLong(elements[0]); if ((l \u0026lt; 0L) || (l \u0026gt; 4294967295L)) { return null; } bytes[0] = (byte) (int) (l \u0026gt;\u0026gt; 24 \u0026amp; 0xFF); bytes[1] = (byte) (int) ((l \u0026amp; 0xFFFFFF) \u0026gt;\u0026gt; 16 \u0026amp; 0xFF); bytes[2] = (byte) (int) ((l \u0026amp; 0xFFFF) \u0026gt;\u0026gt; 8 \u0026amp; 0xFF); bytes[3] = (byte) (int) (l \u0026amp; 0xFF); break; case 2: l = Integer.parseInt(elements[0]); if ((l \u0026lt; 0L) || (l \u0026gt; 255L)) { return null; } bytes[0] = (byte) (int) (l \u0026amp; 0xFF); l = Integer.parseInt(elements[1]); if ((l \u0026lt; 0L) || (l \u0026gt; 16777215L)) { return null; } bytes[1] = (byte) (int) (l \u0026gt;\u0026gt; 16 \u0026amp; 0xFF); bytes[2] = (byte) (int) ((l \u0026amp; 0xFFFF) \u0026gt;\u0026gt; 8 \u0026amp; 0xFF); bytes[3] = (byte) (int) (l \u0026amp; 0xFF); break; case 3: for (i = 0; i \u0026lt; 2; ++i) { l = Integer.parseInt(elements[i]); if ((l \u0026lt; 0L) || (l \u0026gt; 255L)) { return null; } bytes[i] = (byte) (int) (l \u0026amp; 0xFF); } l = Integer.parseInt(elements[2]); if ((l \u0026lt; 0L) || (l \u0026gt; 65535L)) { return null; } bytes[2] = (byte) (int) (l \u0026gt;\u0026gt; 8 \u0026amp; 0xFF); bytes[3] = (byte) (int) (l \u0026amp; 0xFF); break; case 4: for (i = 0; i \u0026lt; 4; ++i) { l = Integer.parseInt(elements[i]); if ((l \u0026lt; 0L) || (l \u0026gt; 255L)) { return null; } bytes[i] = (byte) (int) (l \u0026amp; 0xFF); } break; default: return null; } } catch (NumberFormatException e) { return null; } return bytes; } /** * 获取IP地址 * * @return 本地IP地址 */ public static String getHostIp() { try { return InetAddress.getLocalHost().getHostAddress(); } catch (UnknownHostException e) { } return \u0026#34;127.0.0.1\u0026#34;; } /** * 获取主机名 * * @return 本地主机名 */ public static String getHostName() { try { return InetAddress.getLocalHost().getHostName(); } catch (UnknownHostException e) { } return \u0026#34;未知\u0026#34;; } /** * 从多级反向代理中获得第一个非unknown IP地址 * * @param ip 获得的IP地址 * @return 第一个非unknown IP地址 */ public static String getMultistageReverseProxyIp(String ip) { // 多级反向代理检测 if (ip != null \u0026amp;\u0026amp; ip.indexOf(\u0026#34;,\u0026#34;) \u0026gt; 0) { final String[] ips = ip.trim().split(\u0026#34;,\u0026#34;); for (String subIp : ips) { if (false == isUnknown(subIp)) { ip = subIp; break; } } } return ip; } /** * 检测给定字符串是否为未知，多用于检测HTTP请求相关 * * @param checkString 被检测的字符串 * @return 是否未知 */ public static boolean isUnknown(String checkString) { return StringUtils.isBlank(checkString) || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(checkString); } } 文件流上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 long begin=System.currentTimeMillis(); InputStream fis=multipartFile.getInputStream(); dest = new File(newFileName); FileOutputStream fos=new FileOutputStream(dest); //先定义一个字节缓冲区，减少I/O次数，提高读写效率 byte[] buffer=new byte[10240]; int size=0; while((size=fis.read(buffer))!=-1){ fos.write(buffer, 0, size); } fis.close(); fos.close(); long end=System.currentTimeMillis(); log.info(\u0026#34;使用文件输入流和文件输出流实现文件的复制完毕！耗时：{} 毫秒\u0026#34;,(end-begin)); COS文件上传 ","permalink":"https://zpc2222.github.io/posts/tech/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/","summary":"IP查询的一些方法 IP_URL = \u0026ldquo;http://whois.pconline.com.cn/ipJson.jsp?ip=%s\u0026amp;json=true\u0026quot; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58","title":"Java常用工具类"},{"content":"JVM分析 tag-placeholder #Java jmap命令是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。 打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。 jmap -J-d64 -heap 12105 jmap -heap 19570 -heap 打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 using parallel threads in the new generation. ##新生代采用的是并行线程处理方式 using thread-local object allocation. Concurrent Mark-Sweep GC ##同步并行垃圾回收 Heap Configuration: ##堆配置情况，也就是JVM参数配置的结果[平常说的tomcat配置JVM参数，就是在配置这些] MinHeapFreeRatio = 40 ##最小堆使用比例 MaxHeapFreeRatio = 70 ##最大堆可用比例 MaxHeapSize = 2147483648 (2048.0MB) ##最大堆空间大小 NewSize = 268435456 (256.0MB) ##新生代分配大小 MaxNewSize = 268435456 (256.0MB) ##最大可新生代分配大小 OldSize = 5439488 (5.1875MB) ##老年代大小 NewRatio = 2 ##新生代比例 SurvivorRatio = 8 ##新生代与suvivor的比例 PermSize = 134217728 (128.0MB) ##perm区 永久代大小 MaxPermSize = 134217728 (128.0MB) ##最大可分配perm区 也就是永久代大小 Heap Usage: ##堆使用情况【堆内存实际的使用情况】 New Generation (Eden + 1 Survivor Space): ##新生代（伊甸区Eden区 + 幸存区survior(1+2)空间） capacity = 241631232 (230.4375MB) ##伊甸区容量 used = 77776272 (74.17323303222656MB) ##已经使用大小 free = 163854960 (156.26426696777344MB) ##剩余容量 32.188004570534986% used ##使用比例 Eden Space: ##伊甸区 capacity = 214827008 (204.875MB) ##伊甸区容量 used = 74442288 (70.99369812011719MB) ##伊甸区使用 free = 140384720 (133.8813018798828MB) ##伊甸区当前剩余容量 34.65220164496263% used ##伊甸区使用情况 From Space: ##survior1区 capacity = 26804224 (25.5625MB) ##survior1区容量 used = 3333984 (3.179534912109375MB) ##surviror1区已使用情况 free = 23470240 (22.382965087890625MB) ##surviror1区剩余容量 12.43827838477995% used ##survior1区使用比例 To Space: ##survior2 区 capacity = 26804224 (25.5625MB) ##survior2区容量 used = 0 (0.0MB) ##survior2区已使用情况 free = 26804224 (25.5625MB) ##survior2区剩余容量 0.0% used ## survior2区使用比例 PS Old Generation: ##老年代使用情况 capacity = 1879048192 (1792.0MB) ##老年代容量 used = 30847928 (29.41887664794922MB) ##老年代已使用容量 free = 1848200264 (1762.5811233520508MB) ##老年代剩余容量 1.6416783843721663% used ##老年代使用比例 Perm Generation: ##永久代使用情况 capacity = 134217728 (128.0MB) ##perm区容量 used = 47303016 (45.111671447753906MB) ##perm区已使用容量 free = 86914712 (82.8883285522461MB) ##perm区剩余容量 35.24349331855774% used ##perm区使用比例 垃圾回收统计：jstat -gc 进程id S0C：第一个幸存区的大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 EC：伊甸园区的大小 EU：伊甸园区的使用大小 OC：老年代大小 OU：老年代使用大小 MC：方法区大小 MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间\n堆内存统计：jstat -gccapacity 进程id NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 EC：伊甸园区的大小 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC:当前老年代大小 MCMN:最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代gc次数 FGC：老年代GC次数\n","permalink":"https://zpc2222.github.io/posts/tech/jvm%E5%88%86%E6%9E%90/","summary":"JVM分析 tag-placeholder #Java jmap命令是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。 打印出某个java进程（使用p","title":"JVM分析"},{"content":"将本地的jar上传至私服：\n1 mvn deploy:deploy-file --settings=D:\\java\\apache-maven-3.8.6\\conf\\settings.xml -DgroupId=cmbc.sdk -DartifactId=SADK-CMBC -Dversion=3.1.0.8-SNAPSHOT -Dpackaging=jar -Dfile=D:\\javaDemo\\lib\\SADK-CMBC-3.1.0.8.jar -DrepositoryId=releases -Durl=http://192.168.1.1:8081/repository/maven-snapshots 推送到仓库 mvn deploy:deploy-file -Dfile=xxx-web\\target\\radp-web-1.0.jar -DgroupId=com.richisland.radp -DartifactId=radp-web -Dversion=1.0 -Dpackaging=jar -DrepositoryId=fd-release –Durl=http://xxx.com/repository/release/\n推送zip包\nmvn deploy:deploy-file -Dfile=package.zip -DgroupId=xxx -DartifactId=package -Dversion=1.1 -Dpackaging=zip -DrepositoryId=fd-release –Durl=http://xxx.com/repository/release/\n流水线推送\nmvn deploy:deploy-file -Dfile=E:\\package.tar.gz -DgroupId=xxx -DartifactId=pipelining -Dversion=1.1 -Dpackaging=gz -DrepositoryId=fd-release –Durl=http://xxx.com/repository/release/\n","permalink":"https://zpc2222.github.io/posts/tech/maven/","summary":"将本地的jar上传至私服： 1 mvn deploy:deploy-file --settings=D:\\java\\apache-maven-3.8.6\\conf\\settings.xml -DgroupId=cmbc.sdk -DartifactId=SADK-CMBC -Dversion=3.1.0.8-SNAPSHOT -Dpackaging=jar -Dfile=D:\\javaDemo\\lib\\SADK-CMBC-3.1.0.8.jar -DrepositoryId=releases -Durl=http://192.168.1.1:8081/repository/maven-snapshots 推送到仓库 mvn deploy:deploy-file -Dfile=xxx-web\\target\\radp-web-1.0.jar -DgroupId=com.richisland.radp -DartifactId=radp-web -Dversion=1.0 -Dpackaging=jar -DrepositoryId=fd-release –Durl=http://xxx.com/repository/r","title":"maven"},{"content":"概念 组件 名 概念 IO 流 各种各样的流（文件、数组、缓冲、管道。。。）的处理（输入输出） Channel 通道 代表一个连接，每个Client请对会对应到具体的一个Channel ChannelPipeline 责任链 每个Channel都有且仅有一个ChannelPipeline与之对应，里面是各种各样的Handler handler 事件 用于处理出入站消息及相应的事件，实现我们自己要的业务逻辑 EventLoopGroup I/O线程池 负责处理Channel对应的I/O事件 ChannelInitializer Channel初始化器 ChannelFuture 执行结果 代表I/O操作的执行结果，通过事件机制，获取执行结果，通过添加监听器，执行我们想要的操作 ByteBuf 字节序列 通过ByteBuf操作基础的字节数组和缓冲区 ServerBootstrap 服务器端启动辅助对象 Bootstrap 客户端启动辅助对象 流程图 客户端代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.util.CharsetUtil; @ChannelHandler.Sharable //这个注解是为了线程安全，如果你不在乎是否线程安全，不加也可以 public class ClientHandler extends SimpleChannelInboundHandler\u0026lt;ByteBuf\u0026gt; { //这里的类型可以是ByteBuf，也可以是String，还可以是对象，根据实际情况来 //channelRead0 消息读取方法，注意名称中有个0 //ChannelHandlerContext：通道上下文，代指Channel； //ByteBuf：字节序列，通过ByteBuf操作基础的字节数组和缓冲区，因为JDK原生操作字节麻烦、效率低，所以Netty对字节的操作进行了封装，实现了指数级的性能提升，同时使用更加便利； @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception { System.out.println(\u0026#34;接收到的消息：\u0026#34; + byteBuf.toString(CharsetUtil.UTF_8));//CharsetUtil.UTF_8：这个是JDK原生的方法，用于指定字节数组转换为字符串时的编码格式。 } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //出现异常的时候执行的动作（打印并关闭通道） System.out.println(\u0026#34;exceptionCaught:\u0026#34; + cause.toString()); if (\u0026#34;java.io.IOException: 远程主机强迫关闭了一个现有的连接。\u0026#34;.equals(cause.toString()) || \u0026#34;java.io.IOException: Connection reset by peer\u0026#34;.equals(cause.toString())) { System.out.println(\u0026#34;与服务端断联\u0026#34;); ctx.close().sync(); ctx.flush(); } } } 客户端启用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import io.netty.bootstrap.Bootstrap; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.util.CharsetUtil; import java.net.InetSocketAddress; public class ClientStart { private final String host; private final int port; public ClientStart(String host, int port) { this.host = host; this.port = port; } public static void main(String[] args) throws Exception { new ClientStart(\u0026#34;192.168.20.125\u0026#34;, 8089).run(); } public void run() throws Exception { /** * @Description 配置相应的参数，提供连接到远端的方法 **/ EventLoopGroup group = new NioEventLoopGroup();//I/O线程池 try { Bootstrap bs = new Bootstrap();//客户端辅助启动类 bs.group(group).channel(NioSocketChannel.class)//实例化一个Channel .remoteAddress(new InetSocketAddress(host, port)).handler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;()//通道Channel的初始化工作，如加入多个handler，都在这里进行； { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { /** * 连接建立后，都会自动创建一个管道pipeline，这个管道也被称为责任链，保证顺序执行，同时又可以灵活的配置各类Handler，这是一个很精妙的设计，既减少了线程切换带来的资源开销、避免好多麻烦事，同时性能又得到了极大增强。 */ socketChannel.pipeline().addLast(new ClientHandler());//添加我们自定义的Handler } }); //连接到远程节点；等待连接完成 ChannelFuture future = bs.connect().sync();//这里的sync()表示采用的同步方法，这样连接建立成功后，才继续往下执行； //发送消息到服务器端，编码格式是utf-8 future.channel().writeAndFlush(Unpooled.copiedBuffer(\u0026#34;Hello World\u0026#34;, CharsetUtil.UTF_8)); //阻塞操作，closeFuture()开启了一个channel的监听器（这期间channel在进行各项工作），直到链路断开 future.channel().closeFuture().sync(); } finally { group.shutdownGracefully().sync(); } } } 服务端实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; import io.netty.util.CharsetUtil; import io.netty.util.ReferenceCountUtil; import static java.lang.System.*; @ChannelHandler.Sharable public class ServerHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { //处理收到的数据，并反馈消息到到客户端 ByteBuf byteBuf = (ByteBuf) msg; byte[] bytes = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(bytes); out.println(\u0026#34;收到客户端发过来的消息: \u0026#34; +new String(bytes, CharsetUtil.UTF_8)); //写入并发送信息到远端（客户端） ctx.writeAndFlush(Unpooled.copiedBuffer(\u0026#34;你好，我是服务端，我已经收到你发送的消息\u0026#34;, CharsetUtil.UTF_8)); // 引用计数器及时申请释放不再引用的对象 ReferenceCountUtil.release(byteBuf); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //出现异常的时候执行的动作（打印并关闭通道） out.println(\u0026#34;exceptionCaught:\u0026#34; + cause.toString()); if (\u0026#34;java.io.IOException: 远程主机强迫关闭了一个现有的连接。\u0026#34;.equals(cause.toString()) || \u0026#34;java.io.IOException: Connection reset by peer\u0026#34;.equals(cause.toString())) { out.println(\u0026#34;ExceptionCaught: Client Disconnect The Connection.\u0026#34;); ctx.close().sync(); ctx.flush(); } } } 服务端启动: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import java.net.InetAddress; import java.net.InetSocketAddress; import java.net.NetworkInterface; import java.net.SocketException; import java.util.Enumeration; import java.util.LinkedList; import java.util.List; public class ServerStart { private final int port; public ServerStart(int port) { this.port = port; } public static void main(String[] args) throws Exception { new ServerStart(8089).run(); } /** * 创建两个EventLoopGroup的实例，一个负责接收客户端的连接，另一个负责处理消息I/O * @throws Exception */ public void run() throws Exception { String url = getIpAddress().get(0); InetSocketAddress address = new InetSocketAddress(url, port);//设置监听端口 //Netty的Reactor线程池，初始化了一个NioEventLoop数组，用来处理I/O操作,如接受新的连接和读/写数据 // 1.创建两个事件组,boss用于处理请求的accept事件,work用于请求的read和write事件 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap();//用于启动NIO服务 b.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class) //通过工厂方法设计模式实例化一个channel .localAddress(address) .childHandler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { //ChannelInitializer是一个特殊的处理类，他的目的是帮助使用者配置一个新的Channel,用于把许多自定义的处理类增加到pipline上来 @Override public void initChannel(SocketChannel ch) throws Exception {//ChannelInitializer 是一个特殊的处理类，他的目的是帮助使用者配置一个新的 Channel。 ch.pipeline().addLast(new ServerHandler());//配置childHandler来通知一个关于消息处理的InfoServerHandler实例 } }); //绑定服务器，该实例将提供有关IO操作的结果或状态的信息 ChannelFuture channelFuture = b.bind(address).sync(); System.out.println(\u0026#34;在\u0026#34; + address + \u0026#34;上开启监听\u0026#34;); //阻塞操作，closeFuture()开启了一个channel的监听器（这期间channel在进行各项工作），直到链路断开 channelFuture.channel().closeFuture().sync(); } finally { bossGroup.shutdownGracefully().sync();//关闭EventLoopGroup并释放所有资源，包括所有创建的线程 workerGroup.shutdownGracefully().sync();//关闭EventLoopGroup并释放所有资源，包括所有创建的线程 } } private static List\u0026lt;String\u0026gt; getIpAddress() { List\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); try { for (Enumeration\u0026lt;NetworkInterface\u0026gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) { NetworkInterface intf = en.nextElement(); String name = intf.getName(); if (!name.contains(\u0026#34;docker\u0026#34;) \u0026amp;\u0026amp; !name.contains(\u0026#34;lo\u0026#34;)) { for (Enumeration\u0026lt;InetAddress\u0026gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) { InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) { String ipaddress = inetAddress.getHostAddress(); if (!ipaddress.contains(\u0026#34;::\u0026#34;) \u0026amp;\u0026amp; !ipaddress.contains(\u0026#34;0:0:\u0026#34;) \u0026amp;\u0026amp; !ipaddress.contains(\u0026#34;fe80\u0026#34;)) { list.add(ipaddress); } } } } } } catch (SocketException ex) { String ip = \u0026#34;127.0.0.1\u0026#34;; list.add(ip); } return list; } } ","permalink":"https://zpc2222.github.io/posts/tech/netty%E5%AE%9E%E6%88%98/","summary":"概念 组件 名 概念 IO 流 各种各样的流（文件、数组、缓冲、管道。。。）的处理（输入输出） Channel 通道 代表一个连接，每个Client请对会对应到具体的一个C","title":"Netty实战"},{"content":"命令： sudo /usr/sbin/nginx -s stop sudo /usr/sbin/nginx\n配置项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 user www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## server { listen 80; server_name 192.168.1.100; client_max_body_size 200m; #上传文件的大小 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_send_timeout 180s; # 设置发送超时时间， proxy_read_timeout 180s; # 设置读取超时时间。 #web平台入口工程 location / { root /home/oc/dist; index index.html index.htm; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_ssl_session_reuse off; charset utf-8; } location /admin { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8081; } location /app { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } location /dashboard { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:9080; } } include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } ","permalink":"https://zpc2222.github.io/posts/tech/nginx/","summary":"命令： sudo /usr/sbin/nginx -s stop sudo /usr/sbin/nginx 配置项： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57","title":"Nginx"},{"content":"由此开始 - Obsidian 中文帮助 - Obsidian Publish\nObsidian是基于Markdown文件的本地知识管理软件，并且开发者承诺Obsidian对于个人使用者永久免费。\nMarkdown文件体积小、语法简单、便于迁移。相较于其他双向链接软件迁移后整个双向链接、网络关系崩溃，Obsidian是通过Markdown文件中的语法进行关联的，只需要复制粘贴Obsidian选中的库就可以轻松实现完整地迁移。（虽然配置和插件需要重新设置）\n","permalink":"https://zpc2222.github.io/posts/tools/obsidian/","summary":"由此开始 - Obsidian 中文帮助 - Obsidian Publish Obsidian是基于Markdown文件的本地知识管理软件，并且开发者承诺Obsidian对于个人使用者永久免费","title":"obsidian"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 1.启动nameserver nohup sh bin/mqnamesrv \u0026amp; #### 2.启动broker nohup sh bin/mqbroker -n 139.196.206.182:9876 -c conf/broker.conf autoCreateTopicEnable=true \u0026amp; ## 查看日志 tail -f ~/logs/rocketmqlogs/namesrv.log tail -f ~/logs/rocketmqlogs/broker.log 查看所有topic sh mqadmin topicList -n 139.196.206.182:9876 ## 1.关闭NameServer sh bin/mqshutdown namesrv ## 2.关闭Broker sh bin/mqshutdown broker ","permalink":"https://zpc2222.github.io/posts/tech/rocketmq/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 1.启动nameserver nohup sh bin/mqnamesrv \u0026amp; #### 2.启动broker nohup sh bin/mqbroker -n 139.196.206.182:9876 -c conf/broker.conf autoCreateTopicEnable=true \u0026amp; ## 查看日志 tail -f ~/logs/rocketmqlogs/namesrv.log tail -f ~/logs/rocketmqlogs/broker.log 查看所有t","title":"rocketMQ"},{"content":"shell启动脚本\n1 2 java -Xms1024m -Xmx1024m -Xmn512m -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:7665 -jar oc-app-test.jar \u0026amp; java -jar-Dnet.java.games.input.librarypath=/home/oc/oc-app-test -Xdebug-Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=*:7665/home/oc/oc-app-test/*.jar \u0026amp; nccloud启动脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/sh #根据端口号查询对应的pid #pid=$(netstat -nlp | grep :$port | awk \u0026#39;{print $7}\u0026#39; | awk -F\u0026#34;/\u0026#34; \u0026#39;{ print $1 }\u0026#39;); pid=$(ps -ef | grep \u0026#39;[j]ava -jar -Dnet.java.games.input.librarypath=/home/iom/nc-cloud\u0026#39; | awk \u0026#39;{print $2}\u0026#39;); #杀掉对应的进程，如果pid不存在，则不执行 if [ -n \u0026#34;$pid\u0026#34; ]; then kill $pid; sleep 2 fi java -jar -Dnet.java.games.input.librarypath=/home/iom/nc-cloud -Xdebug -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=*:7666 /home/iom/nc-cloud/*.jar --spring.profiles.active=dev \u0026amp; ","permalink":"https://zpc2222.github.io/posts/tech/shell%E8%84%9A%E6%9C%AC/","summary":"shell启动脚本 1 2 java -Xms1024m -Xmx1024m -Xmn512m -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:7665 -jar oc-app-test.jar \u0026amp; java -jar-Dnet.java.games.input.librarypath=/home/oc/oc-app-test -Xdebug-Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=*:7665/home/oc/oc-app-test/*.jar \u0026amp; nccloud启动脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/sh #根据端口号查询对应的pid #pid=$(netstat -nlp | grep :$port | awk \u0026#39;{print","title":"Shell脚本"},{"content":"windows命令 查看端口占用PID netstat -aon|findstr \u0026ldquo;9000\u0026rdquo;\n查看进程 tasklist|findstr \u0026ldquo;9088\u0026rdquo; 杀进程 taskkill /T /F /PID 9088\n","permalink":"https://zpc2222.github.io/posts/tech/windows/","summary":"windows命令 查看端口占用PID netstat -aon|findstr \u0026ldquo;9000\u0026rdquo; 查看进程 tasklist|findstr \u0026ldquo;9088\u0026rdquo; 杀进程 taskkill /T /F /PID 9088","title":"Sindows"},{"content":"io简介 tag-placeholder\nIO 指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口 在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。\nAIO Java AIO即Async非阻塞，是异步非阻塞的IO。\nBIO Java BIO即Block I/O ， 同步并阻塞的IO。 BIO就是传统的java.io包下面的代码实现。\nNIO NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据 面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。\n一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。\n区别及联系 BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。\nNIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。\nAIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。\n各自适用场景 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。\nNIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。\nAIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持\n","permalink":"https://zpc2222.github.io/posts/tech/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Bio/","summary":"io简介 tag-placeholder IO 指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口 在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的","title":"网络编程IO"},{"content":" 沸月月的博客 关注互联网以及分享IT软件开发经验的个人博客 👉友链格式 名称： 我的个人小站 网址： https://zpc2222.github.io 图标： https://zpc2222.github.io/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉广告位招租 ","permalink":"https://zpc2222.github.io/links/","summary":"沸月月的博客 关注互联网以及分享IT软件开发经验的个人博客 👉友链格式 名称： 我的个人小站 网址： https://zpc2222.github.io 图标： https://zpc2222.github.io/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友","title":"🤝友链"}]