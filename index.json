[{"content":"什么是MybatisPlus MybatisPlus可以节省大量时间，所有的CRUD代码都可以自动化完成 MyBatis-Plus是一个MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 官网：https://baomidou.com/ 使用 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 server: port: 8082 servlet: context-path: /oc-app spring: jackson: time-zone: GMT+8 datasource: dynamic: primary: db1 datasource: db1: # 数据库的JDBC链接 url: jdbc:mysql://127.0.0.1:3306/test?createDatabaseIfNotExist=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;useLegacyDatetimeCode=false\u0026amp;\u0026amp;serverTimezone=Asia/Shanghai # 数据库用户名 username: root # 数据库密码 password: 123456 db2: # 数据库的JDBC链接 url: jdbc:mysql://127.0.0.1:3306/admin?createDatabaseIfNotExist=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;useLegacyDatetimeCode=false\u0026amp;\u0026amp;serverTimezone=Asia/Shanghai # 数据库用户名 username: root # 数据库密码 password: 654321 flyway: # 是否启用flyway enabled: true # 编码格式，默认UTF-8 encoding: UTF-8 # 迁移sql脚本文件存放路径，默认db/migration locations: classpath:db/migration # 迁移sql脚本文件名称的前缀，默认V sql-migration-prefix: V # 迁移sql脚本文件名称的分隔符，默认2个下划线__ sql-migration-separator: __ # 迁移sql脚本文件名称的后缀 sql-migration-suffixes: .sql # 迁移时是否进行校验，默认true validate-on-migrate: true # 当迁移发现数据库非空且存在没有元数据的表时，自动执行基准迁移，新建schema_version表 baseline-on-migrate: true redis: host: 192.168.1.1 port: 6379 password: admin@123! cache: type: REDIS redis: time-to-live: 120 mvc: pathmatch: matching-strategy: ant_path_matcher main: allow-bean-definition-overriding: true # mybatis plus 配置 mybatis-plus: configuration: # 下划线转驼峰 map-underscore-to-camel-case: true #日志打印 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 扫描 xml 文件位置 mapper-locations: classpath:mapper/*Mapper.xml global-config: db-config: # 使用雪花算法主键填充策略 id-type: assign_id 在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹：\n1 2 3 4 5 6 7 @SpringBootApplication @MapperScan(\u0026#34;com.xx.mapper\u0026#34;) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 实现 实体类\n1 2 3 4 5 6 7 @Data public class User { private Long id; private String name; private Integer age; private String email; } 编写 Mapper 包下的 UserMapper接口\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { } service层及实现类\n1 2 3 4 5 6 7 public interface UserService extends IService\u0026lt;User\u0026gt; { } @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper, User\u0026gt; implements UserService { } 注解 @TableId(value = \u0026ldquo;user_id\u0026rdquo;, type = IdType.ASSIGN_ID)\nprivate Long userId; 分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) 如上使用的id为雪花算法生成的，比较长，建议使用自增AUTO，数据库不进行物理删除，而是逻辑删除\n表达式与sql对比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 eq == equal 等于 ne == not equal 不等于 gt == greater than 大于 lt == less than 小于 ge == greater than or equal 大于等于 le == less than or equal 小于等于 in == in 包含（数组） isNull == 等于null isNotNull == 不等于null orderByDesc == 倒序排序 orderByAsc == 升序排序 or == 或者 and == 并且 between == 在2个条件之间(包括边界值) like == 模糊查询 clear == 清除 apply == 拼接sql lambda == 使用lambda表达式 exists == 临时表 常用注解 实体类中创建时间以及修改时间可以加入\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 创建时间 */ @JsonFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; /** * 更新时间 */ @JsonFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; 编写处理器来处理这个注释就会在写操作时候自动生成当前时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 实现自动化操作创建时间和修改时间 */ @Component public class DateTimeFillConfig implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { //设置属性值 this.setFieldValByName(\u0026#34;createdTime\u0026#34;, LocalDateTime.now(),metaObject); this.setFieldValByName(\u0026#34;updatedTime\u0026#34;,LocalDateTime.now(),metaObject); } @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName(\u0026#34;updatedTime\u0026#34;,LocalDateTime.now(),metaObject); } } 复杂查询案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //封装查询条件 QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); //模糊查询 queryWrapper.like(\u0026#34;a.nick_name\u0026#34;, vo.getName()); // 手机号/用户名称查询,当用户名为一串数字时默认使用手机号查询 if (StringUtils.isNotBlank(vo.getNameOrMobile())) { if (NumberUtils.isDigits(vo.getNameOrMobile())) { queryWrapper.and(wq-\u0026gt;wq.like(\u0026#34;b.mobile\u0026#34;, vo.getNameOrMobile()) .or().like(\u0026#34;b.nick_name\u0026#34;,vo.getNameOrMobile())); } else { queryWrapper.like(\u0026#34;b.nick_name\u0026#34;, vo.getNameOrMobile()); } } // 时间范围查询 if (StringUtils.isNotBlank(vo.getStartTime())) { queryWrapper.ge(\u0026#34;a.created_time\u0026#34;, vo.getStartTime()); } if (StringUtils.isNotBlank(vo.getEndTime())) { queryWrapper.le(\u0026#34;a.created_time\u0026#34;, vo.getEndTime()); } // 精准查询 if (StringUtils.isNotBlank(vo.getId())) { queryWrapper.eq(\u0026#34;a.id\u0026#34;, vo.getId()); } //状态不在其中的 if (StringUtils.isBlank(vo.getStatus()) \u0026amp;\u0026amp; \u0026#34;2\u0026#34;.equals(vo.getType())) { queryWrapper.notIn(\u0026#34;a.status\u0026#34;, List.of(1, 2, 3)); } queryWrapper.notIn(\u0026#34;a.status\u0026#34;, List.of(1,2,3)); // 时间进行排序 // where语句后面不能直接增加排序，导致sql解析异常 if (!queryWrapper.isEmptyOfWhere()) { queryWrapper.orderByDesc(\u0026#34;a.created_time\u0026#34;); } IPage\u0026lt;User\u0026gt; pages = getBaseMapper().getPageList(pager, queryWrapper); ","permalink":"https://zpc2222.github.io/posts/tech/mybatisplus/","summary":"什么是MybatisPlus MybatisPlus可以节省大量时间，所有的CRUD代码都可以自动化完成 MyBatis-Plus是一个MyBa","title":"MybatisPlus常用"},{"content":"一些小插件 倒计时 ","permalink":"https://zpc2222.github.io/posts/life/web-plugin/","summary":"一些小插件 倒计时","title":"网页插件"},{"content":"简介 官网地址：\u0026gt; https://www.easy-es.cn\n选择理由：省心，省力，省代码。简单好用，少操心\n引用 pom依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.easy-es\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;easy-es-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--ES的相关依赖版本需要统一下,建议与服务端版本统一--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch.client\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch-rest-high-level-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;7.14.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;7.14.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置 如果是properties，也差距不大\n1 2 3 4 5 6 7 8 9 10 easy-es: # 是否开启EE自动配置,若为false时,则认为不启用本框架 enable: true # ES连接地址+端口 address: 127.0.0.1:9200 # 关闭自带banner banner: false schema: http username: elastic #有设置才填写,非必须 password: elastic 拓展配置\n可缺省,不影响项目启动,为了提高生产环境性能,建议按需配置\n1 2 3 4 5 6 7 8 easy-es: keep-alive-millis: 18000 # 心跳策略时间 单位:ms connectTimeout: 5000 # 连接超时时间 单位:ms socketTimeout: 5000 # 通信超时时间 单位:ms requestTimeout: 5000 # 请求超时时间 单位:ms connectionRequestTimeout: 5000 # 连接请求超时时间 单位:ms maxConnTotal: 100 # 最大连接数 单位:个 maxConnPerRoute: 100 # 最大连接路由数 单位:个 全局配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 easy-es: banner: false # 默认为true 打印banner 若您不期望打印banner,可配置为false global-config: process_index_mode: smoothly #索引处理模式,smoothly:平滑模式,默认开启此模式, not_smoothly:非平滑模式, manual:手动模式 print-dsl: true # 开启控制台打印通过本框架生成的DSL语句,默认为开启,测试稳定后的生产环境建议关闭,以提升少量性能 distributed: false # 当前项目是否分布式项目,默认为true,在非手动托管索引模式下,若为分布式项目则会获取分布式锁,非分布式项目只需synchronized锁. asyncProcessIndexBlocking: true # 异步处理索引是否阻塞主线程 默认阻塞 数据量过大时调整为非阻塞异步进行 项目启动更快 activeReleaseIndexMaxRetry: 60 # 分布式环境下,平滑模式,当前客户端激活最新索引最大重试次数若数据量过大,重建索引数据迁移时间超过60*(180/60)=180分钟时,可调大此参数值,此参数值决定最大重试次数,超出此次数后仍未成功,则终止重试并记录异常日志 activeReleaseIndexFixedDelay: 180 # 分布式环境下,平滑模式,当前客户端激活最新索引最大重试次数 若数据量过大,重建索引数据迁移时间超过60*(180/60)=180分钟时,可调大此参数值 此参数值决定多久重试一次 单位:秒 db-config: map-underscore-to-camel-case: false # 是否开启下划线转驼峰 默认为false table-prefix: daily_ # 索引前缀,可用于区分环境 默认为空 用法和MP一样 id-type: customize # id生成策略 customize为自定义,id值由用户生成,比如取MySQL中的数据id,如缺省此项配置,则id默认策略为es自动生成 field-strategy: not_empty # 字段更新策略 默认为not_null enable-track-total-hits: true # 默认开启,查询若指定了size超过1w条时也会自动开启,开启后查询所有匹配数据,若不开启,会导致无法获取数据总条数,其它功能不受影响. refresh-policy: immediate # 数据刷新策略,默认为不刷新 enable-must2-filter: false # 是否全局开启must查询类型转换为filter查询类型 默认为false不转换 代码 数据模型（相当于MP的entity） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /** * es 数据模型 * \u0026lt;p\u0026gt; **/ @Data @Accessors(chain = true) @IndexName(value = \u0026#34;es_document\u0026#34;, shardsNum = 3, replicasNum = 2, keepGlobalPrefix = true, maxResultWindow = 100) public class Document { /** * es中的唯一id,如果你想自定义es中的id为你提供的id,比如MySQL中的id,请将注解中的type指定为customize或直接在全局配置文件中指定,如此id便支持任意数据类型) */ @IndexId(type = IdType.CUSTOMIZE) private String id; /** * 文档标题,不指定类型默认被创建为keyword类型,可进行精确查询 */ private String title; /** * 文档内容,指定了类型及存储/查询分词器 */ @HighLight(mappingField = \u0026#34;highlightContent\u0026#34;) @IndexField(fieldType = FieldType.TEXT, analyzer = Analyzer.IK_SMART) private String content; /** * 作者 加@TableField注解,并指明strategy = FieldStrategy.NOT_EMPTY 表示更新的时候的策略为 创建者不为空字符串时才更新 */ @IndexField(strategy = FieldStrategy.NOT_EMPTY) private String creator; /** * 创建时间 */ @IndexField(fieldType = FieldType.DATE, dateFormat = \u0026#34;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\u0026#34;) private String gmtCreate; /** * es中实际不存在的字段,但模型中加了,为了不和es映射,可以在此类型字段上加上 注解@TableField,并指明exist=false */ @IndexField(exist = false) private String notExistsField; /** * 地理位置经纬度坐标 例如: \u0026#34;40.13933715136454,116.63441990026217\u0026#34; */ @IndexField(fieldType = FieldType.GEO_POINT) private String location; /** * 图形(例如圆心,矩形) */ @IndexField(fieldType = FieldType.GEO_SHAPE) private String geoLocation; /** * 自定义字段名称 */ @IndexField(value = \u0026#34;wu-la\u0026#34;, fieldType = FieldType.TEXT, analyzer = Analyzer.IK_SMART, searchAnalyzer = Analyzer.IK_SMART, fieldData = true) private String customField; /** * 高亮返回值被映射的字段 */ private String highlightContent; /** * 文档点赞数 */ private Integer starNum; } mapper 1 2 3 4 5 6 /** * mapper 相当于Mybatis-plus的mapper * \u0026lt;p\u0026gt; **/ public interface DocumentMapper extends BaseEsMapper\u0026lt;Document\u0026gt; { } controller 调用接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @RestController @RequestMapping(\u0026#34;/es\u0026#34;) @Tag(name = \u0026#34;es案例\u0026#34;) @RequiredArgsConstructor @Slf4j public class EsController { private final DocumentMapper documentMapper; /** * 初始化插入数据,默认开启自动挡,自动挡模式下,索引会自动创建及更新. 若未开启自动挡,则在此步骤前需先调用创建索引API完成索引创建 * * @return */ @Operation(summary = \u0026#34;添加文档\u0026#34;) @PostMapping(\u0026#34;insert\u0026#34;) public Integer insert(@RequestBody Document document) { document.setGmtCreate(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;))); return documentMapper.insert(document); } @Operation(summary = \u0026#34;批量添加测试\u0026#34;) @PostMapping(\u0026#34;batchInsert\u0026#34;) public void testBatchInsert() { List\u0026lt;Document\u0026gt; documentList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 2; i \u0026lt; 23; i++) { Document document = new Document(); document.setId(Integer.toString(i)); document.setTitle(\u0026#34;测试文档\u0026#34; + i); document.setContent(\u0026#34;测试内容\u0026#34; + i); document.setCreator(\u0026#34;老汉\u0026#34; + i); document.setGmtCreate(LocalDateTime.now().format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;))); document.setCustomField(\u0026#34;自定义字段\u0026#34; + i); Point point = new Point(13.400544 + i, 52.530286 + i); document.setGeoLocation(point.toString()); document.setStarNum(i); if (i == 2) { document.setLocation(\u0026#34;40.17836693398477,116.64002551005981\u0026#34;); document.setStarNum(1); } else if (i == 3) { document.setLocation(\u0026#34;40.19103839805197,116.5624013764374\u0026#34;); } else if (i == 4) { document.setLocation(\u0026#34;40.13933715136454,116.63441990026217\u0026#34;); } documentList.add(document); } int count = documentMapper.insertBatch(documentList); Assert.equals(documentList.size(), count); } /** * 演示根据标题精确查询文章 * 例如title传值为 我真帅,那么在当前配置的索引下,所有标题为\u0026#39;我真帅\u0026#39;的文章都会被查询出来 * 其它各种场景的查询使用,请移步至test模块 * * @param title * @return */ @Operation(summary = \u0026#34;根据标题精确查询文章\u0026#34;) @GetMapping(\u0026#34;/listDocumentByTitle\u0026#34;) public List\u0026lt;Document\u0026gt; listDocumentByTitle(@RequestParam String title) { // 实际开发中会把这些逻辑写进service层 这里为了演示方便就不创建service层了 LambdaEsQueryWrapper\u0026lt;Document\u0026gt; wrapper = new LambdaEsQueryWrapper\u0026lt;\u0026gt;(); wrapper.eq(Document::getTitle, title); return documentMapper.selectList(wrapper); } @Operation(summary = \u0026#34;查询id是1,2,3的\u0026#34;) @GetMapping(\u0026#34;/queryConditionIn\u0026#34;) public List\u0026lt;Document\u0026gt; testConditionIn() { LambdaEsQueryWrapper\u0026lt;Document\u0026gt; wrapper = new LambdaEsQueryWrapper\u0026lt;\u0026gt;(); wrapper.in(Document::getId, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;); List\u0026lt;Document\u0026gt; documents = documentMapper.selectList(wrapper); return documents; } /** * 演示根据title删除文章，同时会被 DeleteInterceptor 拦截，执行逻辑删除 * * @param title * @return */ @Operation(summary = \u0026#34;根据title删除文章\u0026#34;) @GetMapping(\u0026#34;/deleteDocumentByTitle\u0026#34;) public Integer deleteDocumentByTitle(@RequestParam String title) { // 实际开发中会把这些逻辑写进service层 这里为了演示方便就不创建service层了 LambdaEsQueryWrapper\u0026lt;Document\u0026gt; wrapper = new LambdaEsQueryWrapper\u0026lt;\u0026gt;(); wrapper.eq(Document::getTitle, title); return documentMapper.delete(wrapper); } /** * 自定义注解指定高亮返回字段,高亮查询测试 * * @param content * @return */ @Operation(summary = \u0026#34;高亮查询测试\u0026#34;) @GetMapping(\u0026#34;/highlightSearch\u0026#34;) public List\u0026lt;Document\u0026gt; highlightSearch(@RequestParam String content) { // 实际开发中会把这些逻辑写进service层 这里为了演示方便就不创建service层了 LambdaEsQueryWrapper\u0026lt;Document\u0026gt; wrapper = new LambdaEsQueryWrapper\u0026lt;\u0026gt;(); wrapper.match(Document::getContent, content); return documentMapper.selectList(wrapper); } 注解 启动类添加 1 启动类添加@EsMapperScan(\u0026#34;com.xxx.mapper\u0026#34;) mapper扫描注解,功能与MP的@MapperScan一致\n@IndexName 索引名注解，标识实体类对应的索引 对应MP的@TableName注解\n@IndexId ES主键注解\n@IndexField ES字段注解\n启动成功，打印：Congratulations auto process index by Easy-Es is don\n具体使用，可以参考代码里面的test工程，工程名：easy-es-test 路径：cn.easyes.test\n不足 ee源码使用的是1.8版本JDK，实际使用过程中，如果项目是Java17（22年，Java19都发布了），会发现不兼容， 目前暂无解决版本，已提issue，给的结论是:目前还不支持jdk 17\n","permalink":"https://zpc2222.github.io/posts/tech/es%E5%85%A5%E9%97%A8-easy-es/","summary":"简介 官网地址：\u0026gt; https://www.easy-es.cn 选择理由：省心，省力，省代码。简单好用，少操心 引用 pom依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.easy-es\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;easy-es-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--","title":"Es入门-easy-es"},{"content":"Map List中的实体类按照某个字段进行分组并存放至Map中操作 java8之前：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new User(1, 1)); list.add(new User(1, 2)); list.add(new User(2, 1)); list.add(new User(2, 3)); list.add(new User(2, 2)); list.add(new User(3, 1)); Map\u0026lt;Integer, List\u0026lt;User\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(User user : list){ if(map.containsKey(user.getId())){//map中存在此id，将数据存放当前key的map中 map.get(user.getId()).add(user); }else{//map中不存在，新建key，用来存放数据 List\u0026lt;User\u0026gt; tmpList = new ArrayList\u0026lt;\u0026gt;(); tmpList.add(user); map.put(user.getId(), tmpList); } } System.out.println(map.toString()); } Java8后：\n1 Map\u0026lt;Integer, List\u0026lt;MobildUserEntity\u0026gt;\u0026gt; map = userList.stream().collect(Collectors.groupingBy(MobildUserEntity::getStatus)); 树状图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //将list，根据省市区信息分开，展示为树状图 Map\u0026lt;String, List\u0026lt;Station\u0026gt;\u0026gt; lists = stations.stream().filter(x -\u0026gt; x.getProvince() != null \u0026amp;\u0026amp; x.getCity() != null).collect(Collectors.groupingBy(Station::getProvince, LinkedHashMap::new, Collectors.toCollection(ArrayList::new))); //返回格式 List\u0026lt;StationTreeVO\u0026gt; provinceList = new ArrayList\u0026lt;\u0026gt;(); //遍历 for (Map.Entry\u0026lt;String, List\u0026lt;Station\u0026gt;\u0026gt; entry : lists.entrySet()) { StationTreeVO province = new StationTreeVO(); //获取list集合 List\u0026lt;Station\u0026gt; value = entry.getValue(); province.setProvince(entry.getKey()); List\u0026lt;StationTreeVO.City\u0026gt; cityList = new ArrayList\u0026lt;\u0026gt;(); //保持原有顺序-（LinkedHashMap按插曲顺序排序） Map\u0026lt;String, List\u0026lt;Station\u0026gt;\u0026gt; cityStreamList = value.stream().collect(Collectors.groupingBy(Station::getCity, LinkedHashMap::new, Collectors.toCollection(ArrayList::new))); for (Map.Entry\u0026lt;String, List\u0026lt;Station\u0026gt;\u0026gt; cityEntry : cityStreamList.entrySet()) { StationTreeVO.City city = new StationTreeVO.City(); List\u0026lt;StationTreeVO.CityArea\u0026gt; areaList = new ArrayList\u0026lt;\u0026gt;(); city.setCity(cityEntry.getKey()); //获取list集合 List\u0026lt;Station\u0026gt; areaValue = cityEntry.getValue(); Map\u0026lt;String, List\u0026lt;Station\u0026gt;\u0026gt; areaStreamList = areaValue.stream().collect(Collectors.groupingBy(Station::getArea, LinkedHashMap::new, Collectors.toCollection(ArrayList::new))); for (Map.Entry\u0026lt;String, List\u0026lt;Station\u0026gt;\u0026gt; areaEntry : areaStreamList.entrySet()) { StationTreeVO.CityArea area = new StationTreeVO.CityArea(); area.setArea(areaEntry.getKey()); List\u0026lt;Station\u0026gt; stationList = areaEntry.getValue(); area.setStationList(coverTree(stationList)); areaList.add(area); } city.setAreaList(areaList); cityList.add(city); } province.setCityList(cityList); provinceList.add(province); } ","permalink":"https://zpc2222.github.io/posts/tech/java/java-common/","summary":"Map List中的实体类按照某个字段进行分组并存放至Map中操作 java8之前： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void main(String[] args) { List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new","title":"Java常用速记"},{"content":"我喜欢的音乐\nhugo博客插入音乐方法，参考文章：视听 | 我的个人小站 (zpc2222.github.io)\n","permalink":"https://zpc2222.github.io/music/","summary":"我喜欢的音乐 hugo博客插入音乐方法，参考文章：视听 | 我的个人小站 (zpc2222.github.io)","title":"音乐"},{"content":"常用 Chrome 扩展工具，链接多为 Chrome Web Store 项目页面。\n浏览器 扩展管理器：快速管理扩展，对扩展分组启用。\nBookmarks clean up：清理重复书签、空文件夹和失效链接，也能合并重复文件夹。\nBetter History：按日期、小时罗列历史记录，搜索更便捷。\nCookie Editor：管理、修改、导出 Cookie。\n网页优化 Tampermonkey：油猴脚本插件，可修改网页布局、增减内容、自动化操作，常用脚本库为 Greasy Fork。\nFix Contrast：自动校正网页对比度，让网页内容更易阅读和分辨。\nFasterChrome：浏览器预加载链接，提升网络流畅度。\nSuperCopy：一键破解禁止右键、破解禁止选择、破解禁止复制、破解禁止粘贴，启用复制，启用右键，启用选择，启用粘贴。\nAutoPagerize：自动识别 next 或下一页，将网页合并为同一页。2014 年更新，很多规则已失效。\npakku：合并 B 站视频中绝大多数刷屏弹幕。\nEnhanced GitHub：提升 GitHub 易用度。\nSourcegraph：优化 GitHub 代码，支持鼠标悬停、代码搜索、查看引用等。\n标签页 Infinity：自定义你的新标签页。\nzvTabs：一键关闭左侧标签。\nGoTo Tab：关键词搜索，快速定位标签页。\n批量链接 Bulk URL Opener Extension：批量打开链接，也可批量获取当前浏览器内所有页面网址链接。\nLink Grabber：批量提取、筛选、复制网页里各种链接。\nLinkclump：按住 Z 键后，长按鼠标左键进行区域框选，区域内的链接可以进行批量打开、复制、书签，操作中会同步显示区域内的链接数。\nTabCopy：快速复制标签页链接。\n图片视频 ImageAssistant：用于嗅探、分析网页图片并提供批量下载。\nFatkun 图片批量下载：找出当前页面的所有图片，提供按分辨率、链接等筛选图片。\nFireShot：捕捉网页截图。\nScreenity：屏幕录像工具，可对屏幕进行捕获，注释，编辑、标注等。\nPicture-in-Picture Extension：视频画中画。\nVideo Speed Controller：使用快捷方式加快，减慢，推进和回放 HTML5 视频。\n监视爬虫 Auto Refresh Plus | Page Monitor：定时刷新页面；页面监视器，找到或丢失指定文本时，弹出提示。\nDistill Web Monitor：监控网页或源以获取变更，可邮件、手机提示。\nCheck 酱：网页内容监控工具，可以监测网页内容变化，并发送异动到微信/飞书。Check 酱可以部署在 Docker 或浏览器插件。\nWeb Scraper：从网页中提取数据的爬虫。\n网页自动化：UI.Vision PRA, iMacros, Automa。\n实用工具 Vimium C：全键盘操作浏览器，建议开启 chrome://flags/#extensions-on-chrome-urls。\nSingleFile：完整的网页保存到单个文件中，可以对文件名、HTML 内容、样式、图片、字体等进行调整。\nSelectorGadget：轻松获取网页元素的 CSS Path 或 XPath。\nCopy as Markdown：将网页文字转为 markdown 格式文本。\nGet Favicon：快速获取当前网站图标。\nTango：快速制作带截图的流程指南，不过较为简单，可以分享为链接，只适合临时分享的网页操作流程。\nSimilar Sites：发现与您当前正在浏览的网站类似的网站。\n彩云小译：双语对照网页翻译，使用更简单。\nLink to Text Fragment：分享网页并将高亮你选中文本 (仅支持 chrome 浏览器)。\n","permalink":"https://zpc2222.github.io/posts/tools/chrome/","summary":"常用 Chrome 扩展工具，链接多为 Chrome Web Store 项目页面。 浏览器 扩展管理器：快速管理扩展，对扩展分组启用。 Bookmarks clean up：清理重复书签、空文件夹和失效链接，也能合并","title":"Chrome"},{"content":"GitHub Actions GitHub Actions 是一个持续集成和持续交付 (CI/CD) 平台，可用于自动执行构建、测试和部署管道。您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。将 GitHub Actions 命令保存为 main.yml，放于 .github\\workflows 目录下，repo 发生指定调节的改变时，Actions 会自动运行。^[了解 GitHub Actions]\n如果 GitHub Actions 命令中有涉及密码等私密信息，则进入项目仓库的「setting - Secrets - Action」，添加密钥进行加密处理。比如新建密钥 PERSONAL_TOKEN，Actions 命令中使用 ${{ secrets.PERSONAL_TOKEN }} 来指代该密钥。\n不同仓库间复制 复制文件到目的地，文档没变化则不会执行。案例为将当前仓库 main 分支下 docs 的 README.md 文件复制到另一个仓库 rockbenben/LearnData/ 路径下，如果目标路径存在相同文件，则将覆盖。如果让 clean: true 生效，Actions 会将目标路径情况，然后执行复制。此动作需按 Creating a personal access token 建立 个人访问令牌，\n1 2 3 4 - name: Copy file uses: andstor/copycat-action@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} src_path: docs/README.md dst_path: / dst_owner: rockbenben dst_repo_name: LearnData dst_branch: main src_branch: main #clean: true Actions 失败重试 在 job 和 step 中使用 if 语句，只有满足条件时才执行具体的 job 或 step。^[最全总结，GitHub Action 自动化部署]\n1 2 # 任务状态检查函数 success() # 当上一步执行成功时返回 truealways() # 总是返回 truecancelled() # 当 workflow 被取消时返回 truefailure() # 当上一步执行失败时返回 true first_step 会总是执行，second_step 需要上一步 first_step 执行成功才会执行，third_step 只有上一步 second_step 执行失败才执行。当 third_step 与 second_step 命令相同时，就可以达到失败重试的效果了。\n1 2 3 4 jobs: first_job: name: My first job runs-on: ubuntu-latest steps: - name: first_step if: always() - name: second_step if: success() - name: third_step if: failure() 常见问题 GitHub 忽略指定文件 项目路径新建一个命名为 .gitignore 的文件，将想要忽略的文件夹和文件写入 .gitignore 文件，换行分隔。\n比如要忽略 node_modules 文件夹，就直接在文件中输入 node_modules。\n","permalink":"https://zpc2222.github.io/posts/tools/github/","summary":"GitHub Actions GitHub Actions 是一个持续集成和持续交付 (CI/CD) 平台，可用于自动执行构建、测试和部署管道。您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉","title":"GitHub"},{"content":" 正则 30 分钟入门\nLEARN REGEX 中文版\n实用表达式 {} 限定符 (表示固定位数)。比如：\\\\d{5} 匹配长度有 5 个的数字，\\\\d{1,5} 最少匹配 1 个，最长匹配 5 个数字。\n.{30,} 指匹配长度 30 以上的任意字符串。\n[aeiou] 匹配中括号中任意字符。\n[^aeiou] 匹配除了 aeiou 这几个字母以外的任意字符。\nHTTP 链接匹配：https?://[^\\s\u0026quot;。？,，?)#]+，句尾不含空格、中英文逗号、中文句号、问号，仅包含 http 和 https 链接\n万能链接匹配：[a-zA-Z]+://[^\\s\u0026quot;。？,，?)#]+ 匹配万能前缀，如 ftp、tencent、lark。\n匹配行：\n1 2 3 4 5 6 //匹配含某个字符的行 var ZZMactch = \u0026#34;.*\u0026#34; + inputMatch.value + \u0026#34;.*\u0026#34;; //匹配不含指定字符的行 var ZZMactch = \u0026#34;^((?!\u0026#34;+inputMatch.value+\u0026#34;).)*$\u0026#34;; //匹配所有不包括 CSDN 的行 ^((?!CSDN).)*$ 匹配不同文本组，id= 或 contentId= 后的多个数字符号\n1 2 (?\u0026lt;=id=)\\d* (?\u0026lt;=[?\u0026amp;](id|contentId)=)\\d+ ^((?!abc).)*admin((?!abc).)*$ 匹配 不包含 abc 但包含 admin 的字符串，匹配整行。^[https://blog.csdn.net/thewindkee/article/details/52785763]\n((?!social.tmall.com)(?!ugc/detail.html).)*$ 匹配不包含 social.tmall.com 和 ugc/detail.html 的字符串，匹配整行。^[https://blog.csdn.net/xiiii/article/details/89450341]\n[₳$¢₴€₤￥＄《]([a-zA-Z0-9]{11})[₳$¢₴€₤￥＄《] 匹配淘口令，[] 指中内容任意匹配一项皆可。\n前后匹配 前后匹配，前后元素只能出现一次，否则容易覆盖过多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 //匹配任意以 a 开头并以 b 结尾的字符，匹配内容不含 a、b //如果 a 有 n 个，则同一行也会匹配 n 次 (?\u0026lt;=a).+(?=b) //如果 b 有 n 个，则匹配最后一个 b； //如果需要匹配第一个 b，则匹配区加懒惰限定符？，代表重复 1 次或更多次，但尽可能少重复 (?\u0026lt;=.*a).+?(?=b) //匹配任意以 a 开头并以 b 结尾的字符，匹配内容包含 a、b a(?\u0026lt;=a).+(?=b)b //匹配字符串中 a 和词组 abc 间的字符，如果 abc 不存在则去尾部 (?\u0026lt;=.*a).+(?=abc) 正则替换 正则全局替换不能带 \\\\，此时用分割替换更方便。\n1 2 3 var str = \u0026#34;dogdogdog\u0026#34;; var str2 = str.replace(/dog/g,\u0026#34;cat\u0026#34;); #全局替换 var str2 = str.split(\u0026#34;dog\u0026#34;).join(\u0026#34;cat\u0026#34;); #分割替换 表达式修饰符 元字符：区分大小写\n常用正则代码 说明 . 匹配除换行符以外的任意字符 * 匹配 0 个或多个.(有多少匹配多少，贪婪模式) ? 匹配 0 个或 1 个 (至少匹配一个) $ 以什么结尾的，如\\\\d+0$ (以 0 结尾) ^ 以什么开头的，如^http匹配以 http 开头的字符串 \\w 匹配字母或数字或下划线或汉字 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\d 匹配数字 \\D 匹配任意非数字的字符 \\s 匹配任意的空白符（空格 ,制表符 ) \\S 匹配任意不是空白符的字符 \\r 回车符 \\n 换行符 (一般情况下使用\\r\\n 匹配回车换行) \\t 制表符，Tab \\u4e00-\\u9fa5 非中文 常用分组语法\n分类 代码/语法 说明 捕获 (exp) 匹配 exp，并捕获文本到自动命名的组里 (?\u0026lt;name\u0026gt;exp) 匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 (?\u0026rsquo;name\u0026rsquo;exp) (?:exp) 匹配 exp，不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配 exp 前面的位置 (?\u0026lt;=exp) 匹配 exp 后面的位置 (?!exp) 匹配后面跟的不是 exp 的位置 (?\u0026lt;!exp) 匹配前面不是 exp 的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 ","permalink":"https://zpc2222.github.io/posts/tools/regex/","summary":"正则 30 分钟入门 LEARN REGEX 中文版 实用表达式 {} 限定符 (表示固定位数)。比如：\\\\d{5} 匹配长度有 5 个的数字，\\\\d{1,5} 最少匹配 1 个，最长匹配 5","title":"正则表达式"},{"content":"早餐：包子 + 豆浆、桃李面包 + 鲜牛奶。\n午餐：沙拉 + 鸡蛋 + 白肉（鸡、鸭、鱼）。\n晚上：7 点停止进食，饿了吃苹果、沙拉、鸡蛋，鸡蛋只吃蛋白。\n16:8 断时法：每天 8 小时进食，8 点钟早餐，3 点后禁食。\n茶饮 夏天喝适合冷泡的绿茶、红茶、白茶、花茶等，而岩茶与普洱生茶冷泡就不容易好喝。^[冷泡茶和热茶放凉，好喝级别能一样吗？]\n蛮喜欢泰厨的花茶，有新鲜的香茅，但淘宝卖的花茶放了很多糖块。\n零食 炸 (烘烤)：烘烤预热－200 度，20 分钟，芝士鸡排 (胖)\u0026gt; 泰森上校鸡块\u0026gt; 鸡米花，炸鸡排、牛肉馅饼外面有面粉，不适合烘烤。 安井肉丸：撒尿牛肉丸\u0026gt; 包心鱼丸\u0026gt; 仿墨鱼丸？\u0026gt;牛肉丸\u0026gt; 蟹味宝 + 鱼籽包。安井肉丸质量都不错，不过别买量贩装，这是不同种类。 程序员延寿指南 输入 固体：吃白肉（-11%~-3% ACM）、蔬果为主（-26%~-17% ACM），多吃辣（-23% ACM），多吃坚果（-27%~-4% ACM），少吃蛋黄（否则 +7% ACM/0.5 颗/天），中量碳水、多吃植物蛋白（-10% ACM），少吃超加工食物（-62%~-18%） 液体：喝咖啡（-22%~-12% ACM），喝牛奶（-17%~-10% ACM），喝茶（-15%~-8% ACM），少喝或不喝甜味饮料（否则每天一杯 +7% ACM，+多巴胺），戒酒或每周 100g（纯酒精量 (g)=饮酒量 (ml)× 酒精浓度 (%)× 酒精密度 0.8g/ml）内（否则+~50% ACM，无上限） 气体：不吸烟（否则+~50% ACM，-12~-11 年寿命） 光照：晒太阳（-~40% ACM） 药物：二甲双胍（糖尿病人相比正常人可以 +3 年）、复合维生素（-8% 癌症风险）、亚精胺（-60%~-30% ACM）、葡萄糖胺（-39% ACM） 输出 运动：每周 3 次 45 分钟挥拍运动（-47% ACM） 日常：刷牙（-25% ACM） 睡眠：每天睡 7 小时全因死亡率最低；且 22-24 点间最好，早睡 +43% ACM，晚睡 +15% ACM（存在争议） 上下文 体重：减肥（-54% ACM） 在发表在《细胞》杂志的 综述文章 中描述了 长寿饮食，这是一种基于从食物成分和卡路里摄入等饮食各个方面研究的多支柱方法。研究人员报告说，理想情况下，一天的饭菜都在 11—12 小时的窗口内进行，允许每天禁食，每 3—4 个月进行为期 5 天的禁食也可能有助于降低胰岛素抵抗、血压和其他疾病风险因素。朗格描述了长寿饮食在现实生活中的样子：大量的豆类、全谷物和蔬菜；一些鱼;没有红肉或加工肉和极少量的白肉；低糖和精制谷物；一定量的坚果和橄榄油；一些黑巧克力。\n泡澡 浸泡 42℃ 以上的水温最多泡 3-5 分钟，40℃ 可以泡 10 分钟，37℃ 到 39℃ 的温水，可以泡 20-30 分钟。\n泡浴后的清水冲淋是有必要的，头发部位和面部用冷水冲淋则有极其良好的保健和延缓衰老的功效。\n泡浴作用：\n低温、长时间的泡浴 - 失眠、压力带来的疲劳。 上班前或者重大活动前高温或者低温并且短时间的泡浴 - 打起精神。 0-21°，收敛组织器官和神经系统\u0026ndash;冷水浴。 32-40°，舒缓、愉快 - 温水浴。 32-42°，止痛、镇静，浴后无力需要休息 - 热水浴。 全身浴：覆盖肩膀为主，温水 - 提高新陈代谢。 半身浴：肚脐平齐，不增加心脏负担，30-40 分钟，慢慢发汗，上半身披毛巾或间断性加水 - 改善心脏功能，改善冷性体质，特别适合老年人。注意：39°，肚脐，30 分钟以上。 坐浴：20 厘米高度的水平线，浸入腰椎、尾椎、臀部，15 分钟 - 痔疮、便秘、尿路感染、生殖系统护理。 另外，饮酒后最好不要立即去洗澡，这很容易引发心血管病。洗澡时出现头晕、胸闷、眼花等“澡堂综合征”，也需立即停浴，到医院就诊。\n减肥食谱 使用食谱前，先需要养成正确的减重习惯和心态。\n不要让自己饿肚子，每天至少要吃 3 顿正餐。 吃点心或正餐之前和之后都要喝一杯水，进食顺序按蔬菜\u0026gt; 鱼肉蛋\u0026gt; 主食 饭后半小时不要坐下 临睡前至少 1 小时停止用餐，并且要多喝水。 每咬一口食物，都要咀嚼一段时间。从身体真正饱足到大脑产生饱足感需要 15 分钟。吃慢一点，就不容易吃得过多。 每天称体重，然后找出 7 天的平均值。确保体重持续下降就好，不需要规定自己每周必须减掉多少体重。有时候体重可能会增加，尤其是女性在月经期间体内水分潴留，容易水肿，和你的饮食或锻炼习惯没有关系。 每周只减掉 0.5-1 公斤。快速减肥会减掉肌肉，而不是脂肪，而且也很难长期维持体重。 早餐 午餐 晚餐 Day01 谷物牛奶 (燕麦片 40g+ 全脂奶粉 40g+ 蛋白粉 5g+ 黑咖啡 2g)；12 粒巴旦木；苹果 200g 什锦饭 (大米 30g+ 小米 30g+ 甜豌豆 15g+ 松子仁 5g+ 酱牛肉碎 30g+ 胡萝卜丁 30g)；蔬菜沙拉 (生菜 100g+ 熟鸡蛋 + 油醋汁半汤匙 4g)；猕猴桃 120g；无糖酸奶 100g 燕麦米饭 (燕麦粒 20g+ 大米 15g)；油煮蘑菇鸡肉菠菜 (菠菜 200g+ 蘑菇 50g+ 鸡腿 40g+ 香油 1 汤匙 8g)；豆浆 (黄豆 50g) Day02 全麦三明治 (生菜 70g+ 鸡蛋 + 全麦吐司 60g+ 香油 2g)；12 粒原味开心果；牛奶 250g 双色菜花 (西兰花 100g+ 菜花 100g+ 香油 5g)；茄汁虾仁 (虾仁 75g+ 番茄酱 30g+ 油 8g)；二米饭 (小米 30g+ 糙米 30g)；牛奶咖啡 (低脂奶粉 20g+ 黑咖啡 2g)(先吃一半菜花) 木耳小白菜杂煮 (小白菜 150g+ 北豆腐 60g+ 鸡心 60g+ 黑木耳 6g+ 香油 3g)；红豆紫米薏米粥 (紫红糯米 30g+ 薏米 15g+ 赤小豆 30g)；蜜橘 100g(加餐) Day03 红豆紫米薏米粥 (紫红糯米 30g+ 薏米 15g+ 赤小豆 30g)；水煮蛋；果仁菠菜 (菠菜 80g+ 花生仁 10g+ 香油 3g)；牛奶咖啡 (低脂奶粉 20g+ 黑咖啡 2g) 土豆沙拉 (土豆 200g+ 甜豌豆 30g+ 白芝麻 3g+ 鸡蛋 + 千岛酱 1 汤匙 8g)；酱卤鸭肝 60g；无糖酸奶 100g；10 粒小番茄 燕麦小米粥 (燕麦片 30g+ 小米 30g+ 小麦胚芽 10g)；蒸虾皮小油菜 (小油菜 180g+ 虾皮 5g+ 全麦粉 30g+ 花椒油 3g)；烤鸡腿 80g Day04 奶香醪糟燕麦 (醪糟 100g+ 燕麦片 30g+ 全脂奶粉 40g)；鸡蛋；12 粒巴旦木 紫菜蛋花汤 (海苔 4g+ 熟芝麻 1g+ 鸡蛋)；牛奶燕麦 (燕麦片 20g+ 全脂牛奶 250g)；酸奶 100g；小叶橘 150g；全麦吐司 30g 火腿木耳煮油菜 (油菜 250g+ 木耳 10g+ 方火腿 60g+ 香油 1 汤匙 8g)；蒸红薯 180g；无糖酸奶 (酸奶 100g+ 蛋白粉 5g)(先吃油菜) Day05 蒸食物套餐 (铁棍山药 80g+ 糯玉米带轴 150g+ 胡萝卜半根 100g)；奶香黄豆浆 (黄豆 20g+ 黑芝麻 5g+ 全脂奶粉 20g)；鸡蛋羹 (鸡蛋 + 香油 2g)；桂圆 150g 冲杂粮糊 (烤红豆粉 15g+ 燕麦粉 20g+ 小米粉 15g+ 全脂奶粉 10g)；生菜沙拉 (生菜 150g+ 千岛酱 10g)；酸奶 200g；蓝莓 100g；葡萄干 10g 坚果土豆泥 (土豆 250g+ 烤花生碎 12g+ 方火腿 70g)；油煮木耳小白菜 (小白菜 200g+ 木耳 6g+ 香油 4g)；酸奶 100g Day06 香蕉燕麦蛋糕 (香蕉 120g+ 燕麦片 30g+ 鸡蛋 + 牛奶 200g)；核桃仁拌豌豆苗 (豌豆苗/鸡毛菜 100g+ 核桃仁 15g+ 芝麻油 4g) 鸡腿炖四宝 (鸡腿肉 100g+ 鲜蘑 80g+ 黄花菜 10g+ 甜豌豆 80g+ 木耳 10g)；银耳西兰花 (西兰花 200g+ 银耳 8g+ 香油 4g) 炖素三鲜 (冬笋 80g+ 香菇 10g+ 黄豆芽 120g+ 香油半汤匙 4g)；清蒸鱼 (蒸鲈鱼 120g+ 花生油 4g)；烤红薯 250g(按序食用) Day07 苹果全麦煎饼 (苹果肉 180g+ 全麦粉 20g+ 葡萄干 3g+ 全脂奶粉 10g+ 油 3g)；麦胚红枣豆浆 (烤黄豆 15g+ 烤黑芝麻 8g+ 大枣肉 10g+ 熟小麦胚芽 10g) 生菜鸡蛋沙拉 (生菜 200g+ 鸡蛋*2+ 千岛沙拉酱 8g)；麦胚红枣豆浆 (烤黄豆 15g+ 烤黑芝麻 8g+ 大枣肉 10g+ 熟小麦胚芽 10g)；酸奶 150g；猕猴桃 120g 甘薯红米饭 (红薯 100g+ 红米 20g+ 白米 20g)；牛肉炖菜 (牛肉 100g+ 香菇 8g+ 胡萝卜 40g+ 魔芋粉丝 20g)；果仁菠菜 (菠菜 200g+ 花生仁 8g+ 香油 4g) Day08 全麦面包 70g；牛奶 240g；水煮鸡蛋；桂圆 120g；9 粒巴旦木 油煮木耳小白菜鸡 (小白菜 25g+ 卤水豆腐 100g+ 鸡心 50g+ 黑木耳 2g+ 香油 3g)；炖素三鲜 (冬笋 40g+ 香菇 4g+ 黄豆芽 20g+ 香油 2g)；蒸红薯 200g；去皮小叶橘 200g 杂粮糊 (烤红豆粉 13g+ 燕麦粉 13g+ 小米粉 13g+ 脱脂奶粉 4g)；火腿木耳煮油菜 (油菜 100g+ 木耳 5g+ 方火腿 75g+ 香油 5g)；无糖酸奶 130g Day09 香蕉燕麦蛋糕 (香蕉 120g+ 燕麦片 50g+ 鸡蛋 + 牛奶 240g)；15 粒开心果 燕麦小米浓粥 (燕麦片 25g+ 小米 13g+ 小麦胚芽 13g)；生菜沙拉 (生菜 200g+ 千岛酱 4g)；清蒸鱼 (蒸鲈鱼 80g+ 花生油 4g)；豆浆 (黄豆 44g) 二米饭 (小米 38g+ 糙米 15g)；蒸虾皮小油菜 (小油菜 200g+ 虾皮 6g+ 全麦粉 10g)；茄汁虾仁 (虾仁 80g+ 番茄酱 10g+ 花生油 4g)；烤鸡腿肉 45g Day10 苹果全麦煎饼 (苹果肉 105g+ 全麦粉 50g+ 葡萄干 3g+ 全脂奶粉 30g+ 油 3g)；鸡蛋羹 (鸡蛋 + 香油 2g) 蒸土豆 (土豆 200g+ 方火腿 75g+ 花生碎 2g)；茄汁虾仁 (虾仁 80g+ 番茄酱 10g+ 花生油 3g)；猕猴桃 150g 甘薯红米饭 (红薯 50g+ 红米 25g+ 白米 25g)；油煮木耳小白菜鸡 (小白菜 100g+ 卤水豆腐 50g+ 鸡心 50g+ 木耳 4g)；豆浆 (黄豆 30g) Day11 谷物牛奶 (燕麦片 50g+ 全脂奶粉 30g+ 黑咖啡 2g)；鸡蛋；10 粒巴旦木；蜜橘 120g 什锦饭 (大米 50g+ 小米 25g+ 甜豌豆 8g+ 松子仁 2g+ 酱牛肉碎 70g+ 胡萝卜丁 20g)；银耳西兰花 (西兰花 50g+ 银耳 4g+ 香油 4g) 燕麦米饭 (燕麦粒 25g+ 大米 38g)；牛肉炖菜 (牛肉 50g+ 香菇 7g+ 胡萝卜 20g+ 魔芋粉丝 20g)；烤鸡腿肉 50g Day12 奶香醪糟燕麦 (醪糟 69g+ 燕麦片 38g+ 全脂奶粉 30g)；果仁菠菜 (菠菜 150g+ 花生仁 3g+ 香油 3g)；鸡蛋羹 土豆鸡蛋豌豆沙拉 (土豆 300g+ 甜豌豆 16g+ 白芝麻 3g+ 鸡蛋 + 千岛酱 4g)；牛肉炖菜 (牛肉 50g+ 香菇 4g+ 胡萝卜 20g+ 魔芋粉丝 20g+ 香油 2g) 蒸食物套餐 (铁棍山药 100g+ 糯玉米带轴 300g+ 胡萝卜 20g)；油煮蘑菇鸡肉菠菜 (菠菜 50g+ 蘑菇 35g+ 鸡腿 50g+ 香油 5g)；无糖酸奶 120g Day13 红豆紫米薏米粥 (紫红糯米 25g+ 薏米 25g+ 红小豆 13g)；蔬菜沙拉 (生菜 200g+ 熟鸡蛋 + 油醋汁 5g)；牛奶咖啡 (牛奶 240g+ 咖啡 2g) 核桃仁拌豌豆苗 (豌豆苗/鸡毛菜 100g+ 核桃仁 8g+ 香油 3g)；烤红薯 200g；酱牛肉 70g；猕猴桃 150g 麦胚红枣豆浆 (烤黄豆 30g+ 烤黑芝麻 16g+ 大枣肉 20g+ 熟小麦胚芽 20g)；清蒸鱼 (蒸鲈鱼 80g+ 花生油 2g)；果仁菠菜 (菠菜 150g+ 花生仁 2g+ 香油 1g) Day14 鸡蛋生菜三明治 (生菜 150g+ 鸡蛋 + 全麦吐司 88g+ 香油 5g)；牛奶 240g 鸡腿炖四宝 (鸡腿肉 50g+ 鲜蘑 35g+ 黄花菜 4g+ 甜豌豆 8g+ 木耳 4g)；燕麦米饭 (燕麦粒 25g+ 大米 25g)；葡萄干 25g 双色菜花 (西兰花 50g+ 菜花 40g+ 油醋汁 2g)；茄汁虾仁 (虾仁 80g+ 番茄 10g+ 油 2g)；二米饭 (小米 38g+ 糙米 25g)；紫菜蛋花汤 (海苔 2g+ 鸡蛋*1) Day15 红豆紫米薏米粥 (紫红糯米 25g+ 薏米 25g+ 赤小豆 13g)；核桃仁拌豌豆苗 (豌豆苗/鸡毛菜 75g+ 核桃仁 3g+ 香油 2g)；鸡蛋羹 (鸡蛋*1+ 香油 1g)；无糖酸奶 240g 油煮木耳小白菜鸡 (小白菜 100g+ 卤水豆腐 100g+ 鸡心 50g+ 木耳 4g+ 油 5g)；二米饭 (小米 50g+ 糙米 25g) 甘薯红米饭 (红薯 50g+ 红米 25g+ 大米 25g)；牛肉炖菜 (牛肉 50g+ 香菇 4g+ 胡萝卜 20g+ 魔芋粉丝 20g+ 油 5g)；烤鸡腿肉 50g Day16 奶香醪糟燕麦 (醪糟 35g+ 燕麦片 38g+ 全脂奶粉 30g)；鸡蛋；蜜橘 120g 蔬菜沙拉 (生菜 200g+ 鸡蛋 + 油醋汁 5g)；清蒸鱼 (蒸鲈鱼 80g+ 花生油 5g)；蒸土豆 300g 油煮鸡肉蘑菇菠菜 (菠菜菜 100g+ 蘑菇 35g+ 鸡腿肉 75g+ 香油 5g)；蒸红薯 250g；豆浆 (黄豆 50g) Day17 香蕉燕麦蛋糕 (香蕉 80g+ 燕麦片 50g+ 鸡蛋 + 牛奶 240g) 粉蒸土豆鸡肉 (土豆 200g+ 鸡腿肉 50g+ 蒸肉米粉 5g+ 烤花生碎 3g)；双色菜花 (西兰花 50g+ 菜花 80g+ 油醋汁 3g)；酱牛肉 150g；猕猴桃 35g 麦胚红枣豆浆 (烤黄豆 30g+ 烤黑芝麻 16g+ 大枣肉 20g+ 熟小麦胚芽 20g)；火腿木耳煮油菜 (油菜 100g+ 木耳 4g+ 方火腿 75g+ 香油 4g) Day18 鸡蛋生菜三明治 (生菜 150g+ 鸡蛋 + 全麦吐司 88g+ 香油 3g)；奶香黄豆浆 (黄豆 13g+ 黑芝麻 3g+ 全脂奶粉 20g) 杂粮糊 (烤红豆粉 13g+ 燕麦粉 13g+ 小米粉 13g+ 脱脂奶粉 2g)；油煮木耳小白菜鸡 (小白菜 150g+ 卤水豆腐 40g+ 鸡心 75g+ 木耳 4g+ 香油 5g)；苹果 150g 蒸食物套餐 (铁棍山药 60g+ 糯玉米带轴 200g+ 胡萝卜 100g)；鸡腿炖四宝 (鸡腿肉 50g+ 鲜蘑 17g+ 黄花菜 2g+ 甜豌豆 4g+ 黄豆芽 10g)；生菜沙拉 (生菜 50g+ 千岛酱 4g)；无糖酸奶 130g Day19 苹果全麦煎饼 (苹果肉 60g+ 全麦粉 50g+ 葡萄干 3g+ 全脂奶粉 20g+ 油 5g)；牛奶 240g 土豆鸡蛋豌豆沙拉 (土豆 300g+ 甜豌豆 32g+ 白芝麻 2g+ 鸡蛋 + 千岛酱 4g)；茄汁虾仁 (虾仁 80g+ 番茄酱 2g+ 油 10g) 燕麦小米浓粥 (燕麦片 13g+ 小米 38g+ 小麦胚芽 13g)；火腿木耳煮油菜 (油菜 100g+ 木耳 4g+ 方火腿 75g)；无糖酸奶 130g Day20 蒸食物套餐 (铁棍山药 60g+ 糯玉米带轴 200g+ 胡萝卜 100g)；紫菜蛋花汤 (海苔 2g+ 鸡蛋*1)；果仁菠菜 (菠菜 100g+ 花生仁 3g+ 香油 3g) 炖素三鲜 (冬笋 40g+ 香菇 17g+ 黄豆芽 20g+ 香油 3g)；牛肉炖菜 (牛肉 50g+ 香菇 4g+ 胡萝卜 10g+ 魔芋粉丝 20g)；燕麦米饭 (燕麦粒 25g+ 大米 50g)；烤鸡腿肉 50g 什锦饭 (大米 38g+ 小米 25g+ 甜豌豆 8g+ 松子仁 3g+ 酱牛肉碎 70g+ 胡萝卜丁 20g)；银耳西兰花 (西兰花 25g+ 银耳 4g+ 香油 2g) Day21 谷物牛奶 (燕麦片 50g+ 全脂奶粉 30g+ 黑咖啡 2g)；鸡蛋；桂圆 120g 油煮鸡肉蘑菇菠菜 (菠菜菜 100g+ 蘑菇 70g+ 鸡腿肉 50g+ 香油 5g)；烤红薯 200g；猕猴桃 150g；无糖酸奶 130g 粉蒸土豆鸡肉 (土豆 100g+ 鸡腿肉 50g+ 蒸肉米粉 5g+ 烤花生碎 2g)；茄汁虾仁 (虾仁 80g+ 番茄酱 10g+ 油 1g)；二米饭 (小米 25g+ 糙米 13g)；核桃仁拌豌豆苗 (豌豆苗/鸡毛菜 75g+ 核桃仁 5g+ 香油 2g) 以上食谱整理自范志红老师的《吃出好身材－21 天营养食谱》，侵权删。\n食谱注意：\n晚餐时补充复合 B 族维生素药片，乳糖敏感者可以将纯牛奶换成低乳糖奶。 蒸蛋羹可以用水煮蛋替代；鸡心、鸭肝、方火腿可以用鸡腿肉、酱牛肉替换；什锦饭中的酱牛肉碎换成炒鸡丁；松子仁可以换成熟芝麻或开心果碎；小叶橘可以替换成等量其他甜度低的新鲜水果，如草莓或半个苹果等；桂圆可以换成其他自己爱吃、吃了之后胃肠舒服的应季水果，比如橘子、橙子、猕猴桃等。水果可以午饭前一小时食用。 小米、燕麦提前浸泡半小时到一小时再和大米一起煮口感较好。如果没有杂粮粉，可以直接用这些杂粮煮成饭，每次煮多一点，分成几份冷冻起来，每次蒸热吃一份。 食谱部分可进行微调，如果不会做，可直接按原料食用。 ","permalink":"https://zpc2222.github.io/posts/life/eat/","summary":"早餐：包子 + 豆浆、桃李面包 + 鲜牛奶。 午餐：沙拉 + 鸡蛋 + 白肉（鸡、鸭、鱼）。 晚上：7 点停止进食，饿了吃苹果、沙拉、鸡蛋，鸡蛋只吃蛋白。 16:8 断时法","title":"健康饮食"},{"content":"自身健康 尿素乳膏：柔软皮肤，防止干裂，深层滋润。\n维 a 酸乳膏：更新表皮，去除角质，避光只能晚上用。\n壬二酸：疏通毛孔堵塞，改善黑头。需建立耐受，遵循 SCT 法则：从短时间到长时间，每天每次 5-10 分钟递增；刚开始涂抹，可以在脸上停留 5-10 分钟后立即清水清洗掉，然后继续下一步护肤步骤，第二天时间拉长到 20 分钟，以此类推，直到在面部停留超过 1-2 小时以上无不适，可以尝试过夜。\n黑头：白天用壬二酸（5 分钟），晚上用维 a 酸。\n看病技巧 如果在网上挂不到专家的号，可以尝试电话联系科室问一下能不能当天加号，有的专家是允许加号的，只不过可能会加到当天比较晚的时候，出检查结果的时候专家就下班了。^[不用迷信主任，要是真有大病，年轻大夫会领着你去找的……]\n如果对自己病情没有很多了解的话，建议早上空腹去，以免抽不了血。如果对自己要做的检查有大致了解的话，建议查一下注意事项，提前做好准备，比如做核磁共振身上不要带金属，女生最好穿无钢圈无挂钩的 bra，比如散瞳后不要驾驶等等。\n人这一生中还是得常见病的概率大，没必要迷信主任医师。建议首次看病不必找资历太高的医生，如果你的病真的到了需要找老大夫看看的地步，年轻大夫会领着你去找的。\n上午看病的人多，下午少，周一多，周五少，尽量避开周一上午。刮风下雨是看病的最佳时机，雨越大，人越少。\n^[“为了您和家人的健康，请不要在星期一上午看病”，超实用看病指南]\n","permalink":"https://zpc2222.github.io/posts/life/medical/","summary":"自身健康 尿素乳膏：柔软皮肤，防止干裂，深层滋润。 维 a 酸乳膏：更新表皮，去除角质，避光只能晚上用。 壬二酸：疏通毛孔堵塞，改善黑头。需建立耐受，","title":"医疗药品"},{"content":"waiting list 先看看闲鱼上是否有官翻或代理商渠道，一般会有 5-8 折。\n硬盘 越来越觉得网盘不如硬盘，机械硬盘更实惠，刚买了个2T的西部，300多，之前淘汰下来的暂时没法用了，用硬盘盒，当备用\n暂不考虑 智能手表 小米手环7Pro\n书房 显示器 书桌配的主显示器使用科睿 27 寸 2K 144Hz（27E1QPlus），因为居住地主要是娱乐，非版本，暂不考虑双屏\n键盘鼠标 罗技G102二代有线鼠标，21年9月买的，用起来还可以，没有花里胡哨的灯光\n摄像头 基本没用，已经拆下来了\n书桌灯 小米台灯，可连米家APP，远程控制\n升降桌 暂时不考虑，但是使用了个增高支架，在家都是站着玩电脑\n台式机 2016年跟同学一起组的一个E31231的主机，GTX960显卡；\n除显示器外，花了6000多，用到现在\n除了上个月加了一个8G的内存条，换了一块机械硬盘，其他的没有任何变动，还能再战3年！？\n游戏手柄 用的极少，好久之前玩鬼泣用过，基本吃灰\n数码 降噪耳机 头戴式外都放弃，尤其是入耳式，难受，坐公交地铁听歌太伤耳朵了\n充电器 1.小米10的原装充电器及原装线，放在家里备用\n2.京东购买的氮化镓充电器33w(85块钱)，小巧，唯一不方便就是type-C口的，不好替换\n运动 筋膜枪 小米mini筋膜枪\n健康 体重秤 16年买的云麦的，已丢 21年买了一个新的，不支持云同步，但基本够用\n泡脚桶 咸鱼买了一个，折叠的，好收纳。事实上，并不好用\n家居 消毒液^[消毒剂选购不完全指南] 84 消毒液：爱特福、龙安、蓝月亮、康威龙 二氧化氯消毒片：星帮尼，二氧化氯消毒剂从安全性角度是高于含氯消毒剂的。 用于餐饮具、瓜果蔬菜等消毒时，有效二氧化氯成分的使用浓度 100–150mg/L，浸泡作用时间 10–20min。 虽然二氧化氯目前被认为是对人体无毒害的成分，但为了保险起见，应及时用清水洗净残留消毒液才能继续使用。 季铵盐消毒液：适用于处理衣物消毒，品牌推荐：康威龙、洛娃 不要将消毒液与洗衣液及柔顺剂同时使用，以免使各自的功效减弱。清洁、消毒是两个独立的过程，建议先洗干净再进行消毒，消毒效果更佳。 小物 能面具 (树脂)，带眼镜不方便使用。 宝工（Pro\u0026rsquo;sKit）NT-309-C 智慧型非接触式感应电笔 测电笔 验电笔 内裤清洗机 洗杯器：一按就能清洗杯子，非常方便，可惜需要水槽有多余的出水口。^[Room Tour ｜新家的厨房里有什么？] ","permalink":"https://zpc2222.github.io/posts/life/shopping/","summary":"waiting list 先看看闲鱼上是否有官翻或代理商渠道，一般会有 5-8 折。 硬盘 越来越觉得网盘不如硬盘，机械硬盘更实惠，刚买了个2T的西部，300多，之前淘汰下来","title":"购物"},{"content":"基于Hugo部署静态博客 `先给大家介绍下：\nhugo号称是The world’s fastest framework for building websites，是由go语言编写的，编译速度和运行速度都是杠杠的。不像hexo依赖于node.js，项目依赖模块多，hexo g生成网页也比较慢\n选择方面：\n静态博客框架jekyll、hexo和hugo三者 Hugo ：51.5k Github地址/官网地址/主题汇总1/主题汇总2/主题汇总3 Jekyll：42.6k Github地址/官网地址/主题汇总1/主题汇总2/主题汇总3 Hexo： 32.6k Github地址/官网地址/主题汇总 Hugo使用go语言是一种编译型语言，速度非常快，而Jekyll使用ruby编写，hexo使用nodejs编写 静态网站，hugo的next主题部署 Jekyll 有github支持，可以将markdown文件直接放到git仓库，github会自动生成网页文件。（Github一直是一个亲ruby的社区） Hexo提供了方便的部署命令，可以做到一条命令部署到github上。 Hugo的官方文档写的非常好，部署简洁。前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 因为种种原因，本人最早用的Jekyll，后来发现Hexo主题更多，但是文章多的时候都比较慢（静态博客，每次都是全量生成的）,Hugo完美解决了这个问题，唯一的劣势就是主题不太多，但是程序员嘛，能用就行了！\n下面开始正文\n安装hugo环境 Hugo的安装有很多方式，Install Hugo | Hugo (gohugo.io) ，根据个人喜好可以自行安装。\nReleases · gohugoio/hugo (github.com) 下载最新版本，建议下载最新的，hugo_extended_0.104.2_windows-amd64.zip 环境变量配置 下好之后找个空文件夹放了，比如我这里用的D:\\Program Files\\hugo 修改系统的环境变量，将hugo.exe所在文件夹添加到里面 输入 hugo version 正确显示版本即可。\n下载模板 克隆模板 git clone https://github.com/zpc2222/hugo-blog.git 修改配置项config.yml 这里不做详细解释，看里面直接修改就行了 运行 hugo serve -D\n-D表示草稿也要渲染，-serve表示启动一个本地服务器，即时渲染，方便修改。 hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production。 由于本地 development 环境的限制, 评论系统**, **CDN 和 fingerprint 不会在 development 环境下启用。 你可以使用 hugo serve -e production 命令来开启这些特性。 值得一提的是不论输入的是server还是serve都是一样的。\n在浏览器中前往它给出的 http://localhost:1313 就能看到你刚生成的博客了。\n当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新.\n现在再输入指令\nhugo -D\n这会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上。\n确认无误后就要把它发到公网上了，这里采用 GitHub pages 进行部署（当然，也有很多种方法也能达成这一目的）\nGitHub pages部署 如果你是第一次使用 GitHub，请自行搜索如何配置，这里不做讲解！\n首先确保你有一个 GitHub 账号，然后新建一个仓库，名为yourname.github.io，注意，你应该保证这里的 your name 为你的 GitHub 账号名称！然后再进行以下步骤：\n1 2 3 4 5 6 7 cd public git init git remote add origin https://github.com/yourname/yourname.github.io.git #此URL可在你的repo中找到 git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master 自动推送脚本： 1 2 3 4 5 6 hugo -D cd public git add . git commit -m \u0026#34;update %date%,%time%\u0026#34; git push origin master pause GitHub自动构建： 点击Actions选择simple workflow，内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # This is a basic workflow to help you get started with Actions name: hugo-deploy-CI # Controls when the action will run. on: push # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # docs：https://github.com/peaceiris/actions-gh-pages deploy: runs-on: ubuntu-20.04 steps: - name: Git checkout uses: actions/checkout@v2 - name: Setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.104.0\u0026#39; extended: true - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} external_repository: zpc2222/zpc2222.github.io # 修改为自己的地址 publish_dir: ./public keep_files: true publish_branch: master 值得注意的是在最后一条Deploy中应使用with而非env，应使用deploy_key而非其他的名字。但目前网上大部分教程都没提及这一点，甚至有的还错误地使用！（使用的我模板可以跳过这步，在工程里直接修改EXTERNAL_REPOSITORY后的路径即可）\n上面操作完成后，你会发现action还是会报错的，因为personal_token（个人令牌）你没有生成，需要在仓库内配置下，名字是PERSONAL_TOKEN，value则是个人令牌，最好不要设置有效期： 令牌如何生成，这里不做讲述 然后每次提交代码，本工程的定时任务，会将静态的页面自动发布到 youname.github.io功能内，这个工程会自动发布到gitpages。如果没有配置的，可以检查下分支是否正确，我默认配置的是master 圈红的注意。\n","permalink":"https://zpc2222.github.io/posts/blog/blog-github/","summary":"基于Hugo部署静态博客 `先给大家介绍下： hugo号称是The world’s fastest framework for building websites，是由go语言编写的，编译速度和运行速度","title":"基于github部署静态博客"},{"content":"仅以此篇文章来测试下在通过 Hugo 引擎来建站时，是否支持 Markdown 文件内容中所写的各种语法，并展示下实际的效果。\n标题样式 让我们从所有可能的标题开始，在 HTML 中 \u0026lt;h1\u0026gt;-\u0026lt;h6\u0026gt;元素分别表示六个不同级别的标题样式，其中 \u0026lt;h1\u0026gt; 为最大标题，\u0026lt;h6\u0026gt;为最小标题，效果如下：\n标题 1 标题 2 标题 3 标题 4 标题 5 标题 6 段落格式 根据 W3C 定义的 HTML5 规范，HTML 文档由元素和文本组成。每个元素的组成都由一个开始标记表示，例如： \u0026lt;body\u0026gt; ，和结束标记表示，例如： \u0026lt;/body\u0026gt; 。（某些开始标记和结束标记在某些情况下可以省略，并由其他标记暗示。） 元素可以具有属性，这些属性控制元素的工作方式。例如：超链接是使用 a 元素及其 href 属性形成的。\nMarkdown 语法 1 ![图像说明](图像地址) HTML IMG 标签 1 \u0026lt;img src=\u0026#34;图像地址\u0026#34; width=\u0026#34;宽度\u0026#34; height=\u0026#34;高度\u0026#34; /\u0026gt; SVG 格式 1 \u0026lt;svg\u0026gt;xxxxxx\u0026lt;/svg\u0026gt; 列表类型 有序列表 第一个元素 第二个元素 第三个元素 无序列表 列表元素 另一个元素 和其它元素 嵌套列表 借助 HTML 的 ul 元素来实现。\n第一项 第二项 第二项第一个子项目 第二项第二个子项目 第二项第二分项第一分项 第二项第二分项第二分项 第二项第二分项第三分项 第二项第三个子项目 第二项第三分项第一分项 第二项第三分项第二分项 第二项第三分项第三分项 第三项 自定义列表 通过 HTML 的 dl 元素还支持自定义列表（表格列表）。\nHugo 目录结构 assets config.toml content data theme static Hugo 模板 基础模板 列表模板 单页模板 块引用 blockquote 元素表示从另一个源引用的内容，可以选择引用必须在 footer 或 cite 元素中，也可以选择使用注释和缩写等行内更改。\n引用文本 这一行也是同样的引用 同样你也在 blockquote 中使用 Markdown 语法书写\n带有引文的 Blockquote 元素效果。\n我的目标不是赚大钱,是为了制造好的电脑。当我意识到我可以永远当工程师时，我才创办了这家公司。\n— 史蒂夫·沃兹尼亚克 根据 Mozilla 的网站记录，Firefox 1.0 于 2004 年发布，并取得了巨大成功。\n表格 表格并不算是 Markdown 的核心要素，但 Hugo 同样支持它。\nID 创建者 模型 年份 1 Honda Accord 2009 2 Toyota Camry 2012 3 Hyundai Elantra 2010 可以使用 : （英文格式冒号）来对表格内容进行对齐。\n表格 可以是 很酷 左对齐 居中 右对齐 左对齐 居中 右对齐 左对齐 居中 右对齐 同样也可以在表格中使用 Markdown 语法。\n表格 中 使用 Markdown 语法 斜体 粗体 中划线 代码块 Code 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其它元素： abbr、sub、sup、kbd等等 GIF 是位图图像格式。\nH2O\nC6H12O6\nXn + Yn = Zn\n按X获胜。或按CTRL+ALT+F显示 FPS 计数器。\n比特作为信息论中的信息单位，也被称为 shannon ，以信息论领域的创始人 Claude shannon 的名字命名。\n参考：\n来自 Mainroad 主题的 Basic Elements 内容 ","permalink":"https://zpc2222.github.io/posts/blog/markdown-use/","summary":"\u003cp\u003e仅以此篇文章来测试下在通过 \u003ccode\u003eHugo\u003c/code\u003e 引擎来建站时，是否支持 \u003ccode\u003eMarkdown\u003c/code\u003e 文件内容中所写的各种语法，并展示下实际的效果。\u003c/p\u003e","title":"Markdown 语法支持"},{"content":"关于 integrity 的错误 错误描述 在 Github Pages 上部署 Hugo 博客后，网站样式丢失，打开浏览器 F12 控制台可以发现错误：Failed to find a valid digest in the 'integrity' attribute for resource \u0026quot;xxx.css\u0026quot;, The resource has been blocked.。\n解决办法 我用的是 PaperMod 主题，发现很多人使用hugo用这个主题，都会有这个问题，大部分的说明就是资源被墙了，然后用CDN加速，但是那么复杂，咱也不会啊，还在还有另一种解决办法（我是解决了，别人不一定，可以做个参考）\n修改html 文件 给出的解决办法是将网站中代表每个模块首页的 index.html 文件里面的 integrity 属性的值置空，我试着将网站首页的 index.html 文件改了一下，确实可以解决问题。但这么多 index.html 文件，一个个手改，工作量太大，也会容易遗漏。另外，即便这次改好了，后面再次重新发布文章的时候，就又会将其覆盖，所以这个方法并不可行。\n修改基类 html 文件 后面倒是在 Satckoverflow 上发现了一个类似的问题。下面有人回复说是需要将 assets 文件夹下的 head.html 中的 integrity 的值置空，就可以一劳永逸了，以后每次发布文章也不用担心被覆盖。可是按照他的路径我并没找到该文件，经过一番试错，最后在 themes\\PaperMod\\layouts\\partials 文件夹下找到一个 head.html 文件，发现里面确实有 integrity=\u0026quot;{{ $stylesheet.Data.Integrity }}\u0026quot; 这么一句代码，把它改为 integrity=\u0026quot;\u0026quot; 然后重新发布，发现效果杠杠的~\n一个后端，搜了一天多前端的问题，虽然还是不懂，但是问题好歹解决了，网站正常访问了！\n","permalink":"https://zpc2222.github.io/posts/blog/blog-question/","summary":"关于 integrity 的错误 错误描述 在 Github Pages 上部署 Hugo 博客后，网站样式丢失，打开浏览器 F12 控制台可以发现错误：Failed to find a valid digest in the 'integrity' attribute for resource \u0026quot;xxx.css\u0026quot;, The resource has been bloc","title":"部署hugo问题"},{"content":"登录框架 使用的spring security框架，通过过滤器进行拦截， 登录的时候通过jwt生成token 调用接口，携带token，同时刷新token时长 除了登录接口及 swagger，其他的都进行拦截\n过滤器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { private static final String[] EXCLUDE_URL = {\u0026#34;/doc.html\u0026#34;,\u0026#34;/login\u0026#34;}; /** * 认证失败处理类 */ private final AuthenticationEntryPointImpl unauthorizedHandler; private final JwtAccessDeniedHandler jwtAccessDeniedHandler; private final JwtAppletTokenUtils jwtUtil; public WebSecurityConfig(AuthenticationEntryPointImpl unauthorizedHandler, JwtAccessDeniedHandler jwtAccessDeniedHandler, JwtAppletTokenUtils jwtUtil) { this.unauthorizedHandler = unauthorizedHandler; this.jwtAccessDeniedHandler = jwtAccessDeniedHandler; this.jwtUtil = jwtUtil; } @Override protected void configure(HttpSecurity httpSecurity) throws Exception { httpSecurity // CSRF禁用，因为不使用session .csrf().disable() // 认证失败处理类 .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).accessDeniedHandler(jwtAccessDeniedHandler) // 防止iframe 造成跨域(这一段不写会导致swagger访问不了) .and().headers().frameOptions().disable().and() // 基于token，所以不需要session .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() // 过滤请求 .authorizeRequests() // 放行OPTIONS请求 .antMatchers(HttpMethod.OPTIONS, \u0026#34;/**\u0026#34;).permitAll() // 允许匿名访问接口 .antMatchers(EXCLUDE_URL).permitAll() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); httpSecurity.apply(new TokenConfigurer(jwtUtil)); } /*** * 核心过滤器配置方法 * @param web */ @Override public void configure(WebSecurity web) { web.ignoring().antMatchers(\u0026#34;/doc.html\u0026#34;, \u0026#34;/webjars/**\u0026#34;, \u0026#34;/**/api-docs/**\u0026#34;,\u0026#34;/login\u0026#34;,\u0026#34;/pay/callback\u0026#34;,\u0026#34;/pay/refundCallback\u0026#34;,\u0026#34;/pay/callback\u0026#34;); } static class TokenConfigurer extends SecurityConfigurerAdapter\u0026lt;DefaultSecurityFilterChain, HttpSecurity\u0026gt; { private final JwtAppletTokenUtils jwtUtil; public TokenConfigurer(JwtAppletTokenUtils jwtUtil) { this.jwtUtil = jwtUtil; } @Override public void configure(HttpSecurity http) { JwtAuthenticationTokenFilter beforeFilter = new JwtAuthenticationTokenFilter(jwtUtil); http.addFilterBefore(beforeFilter, UsernamePasswordAuthenticationFilter.class); } } } Jwt 生成方法： 1 2 3 public String createToken(Map\u0026lt;String, Object\u0026gt; claims) { return Jwts.builder().claim(AUTHORITIES_KEY, JSONObject.toJSONString(claims)).setId(UUID.randomUUID().toString()).setIssuedAt(new Date()).setExpiration(new Date((new Date()).getTime() + tokenValidityInSeconds*1000)).compressWith(CompressionCodecs.DEFLATE).signWith(key, SignatureAlgorithm.HS512).compact(); } Jwt 校验方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public boolean validateToken(String authToken) { try { Date expiration = getExpirationDateFromToken(authToken); if (ObjectUtil.isNotNull(expiration) \u0026amp;\u0026amp; expiration.getTime() - System.currentTimeMillis() \u0026lt;= LAST_EXPIRE_TIME) { // 刷新过期时间 Claims claims = getClaimsFromToken(authToken); claims.setExpiration(new Date((new Date()).getTime() + tokenValidityInSeconds*1000)); } return true; } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) { log.error(\u0026#34;Invalid JWT signature.\u0026#34;, e); } catch (ExpiredJwtException e) { log.error(\u0026#34;Expired JWT token.\u0026#34;, e); } catch (UnsupportedJwtException e) { log.error(\u0026#34;Unsupported JWT token.\u0026#34;, e); } catch (IllegalArgumentException e) { log.error(\u0026#34;JWT token compact of handler are invalid.\u0026#34;, e); } return false; } public Date getExpirationDateFromToken(String token) { Date expiration; try { final Claims claims = getClaimsFromToken(token); expiration = claims.getExpiration(); } catch (Exception e) { expiration = null; } return expiration; } private Claims getClaimsFromToken(String token) { Claims claims; try { claims = Jwts.parser().setSigningKey(key).parseClaimsJws(token).getBody(); } catch (Exception e) { claims = null; } return claims; } ","permalink":"https://zpc2222.github.io/posts/tech/java/spring-security-framework/","summary":"登录框架 使用的spring security框架，通过过滤器进行拦截， 登录的时候通过jwt生成token 调用接口，携带token，同时刷新to","title":"登录框架"},{"content":"Git操作 常用命令 1 2 3 git add . git commit -m git push origin HEAD:refs/for/dev 修改最新一次的提交 1 2 3 4 5 git rebase -i dev~1 pick修改为edit ，保存 git add . git rebase --continue git push origin HEAD:refs/for/dev 改日志 1 2 3 git rebase -i git commit --amend -》修改里面日志信息，vim修改 git rebase --continue 绑定本地分支与远端的分支，直接pull 1 git branch --set-upstream-to=origin/work work git强制覆盖本地仓库 拉取所有更新，不同步；\ngit fetch \u0026ndash;all\n本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)；`\ngit reset \u0026ndash;hard origin/master\n再更新一次（其实也可以不用，第二步命令做过了其实）`\ngit pull\ngit fetch \u0026ndash;all \u0026amp;\u0026amp; git reset \u0026ndash;hard origin/master \u0026amp;\u0026amp; git pull\n问题 ssh：no matching host key type found. Their offer: ssh-dss\n解决：\n在.ssh目录下创建config文件，并复制以下信息填入：\n1 2 3 4 Host * HostKeyAlgorithms +ssh-rsa PubkeyAcceptedKeyTypes +ssh-rsa KexAlgorithms +diffie-hellman-group1-sha1 拉取问题 git github在内网环境设置代理访问报错： fatal: unable to access \u0026lsquo;https://github.com/XXX': Could not resolve host: github.com Unable to fetch in submodule path ‘XXX\u0026rsquo;\n解决：\n1 2 $ git config --global http.proxy 127.0.0.1:10809 $ git config --global https.proxy https://10.xxx.xxx.xxx:1234 配置为代理，即可\n配置项 git config \u0026ndash;global user.email \u0026ldquo;gitHub邮箱\u0026rdquo;\ngit config \u0026ndash;global user.name \u0026ldquo;gitHub用户名\u0026rdquo;\ngit config \u0026ndash;global \u0026ndash;edit\n配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [alias] s= status br = branch co = checkout df = diff amend = commit --amend --no-edit cs = commit -s u= add -u pub = \u0026#34;!f() { git push origin HEAD:refs/for/$(gitrev-parse --abbrev-ref HEAD); }; f\u0026#34; sub = \u0026#34;!f() { git pull --rebase origin $(git rev-parse --abbrev-refHEAD); }; f\u0026#34; draft = \u0026#34;!f() { git push origin HEAD:refs/drafts/$(git rev-parse--abbrev-ref HEAD); }; f\u0026#34; [user] name=xxx email=xxx@163.com [core] editor=vi autocrlf=false safecrlf=false [commit] template=D:\\\\xxx.template [gui] encoding=utf-8 Git报错 Unable to negotiate with xxx.xxx.xxx.xxx port XX: no matching host key type found. Their offer: ssh-rsa,ssh-dss fatal: Could not read from remote repository.\n解决： 前提： 在排除没有配置公钥的情况下。\n在Git的安装目录下 Git \u0026gt; etc \u0026gt; ssh 文件夹下找到 ssh_config 文件 。 在文件末尾添加一下代码。 1 2 3 4 5 # 注意这里的 xxx.com 是没有 https:// 的 # 如 https://github.com/， 填写 github.com 即可（最后的斜杆也不能要）。 Host xxx.com HostkeyAlgorithms +ssh-rsa PubkeyAcceptedAlgorithms +ssh-rsa ","permalink":"https://zpc2222.github.io/posts/tools/git/","summary":"Git操作 常用命令 1 2 3 git add . git commit -m git push origin HEAD:refs/for/dev 修改最新一次的提交 1 2 3 4 5 git rebase -i dev~1 pick修改为edit ，保存 git add . git rebase --continue git push origin HEAD:refs/for/dev 改日志 1 2 3","title":"Git"},{"content":"Shell命令 添加用户 useradd -d /home/zpc -m zpc\n查看端口是否开放 /sbin/iptables -L -n\n开端口 firewall-cmd \u0026ndash;zone=public \u0026ndash;add-port=81/tcp \u0026ndash;permanent\n重启防火墙 systemctl restart firewalld.service\n查看端口 firewall-cmd \u0026ndash;list-ports\n安装JKD wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz\n安装jdk17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /usr/lib/jvm/java-17-openjdk-amd64/ tar -zxvf jdk-17_linux-x64_bin.tar.gz sudo mv jdk-17.0.1 /usr/local/ sudo vim /etc/profile export JAVA_HOME=/usr/local/jdk-17.0.1 export CLASSPATH=.:JAVA_HOME/lib export PATH=.:JAVA_HOME/bin:$PATH source /etc/profile 压缩命令 tar.gz 使用tar命令进行解压 tar -zxvf java.tar.gz\ngz文件的解压 gzip 命令 gzip -d java.gz\n解压gz文件到特定目录,tar.gz包内提取某个文件在指定目录下 tar包 tar tvf yourtarfile |grep fileyouwant， tar xvf yourtarfile fileyouwant(copy上面的全路径用绝对路径)\ntar.gz包 tar ztvf yourtargzfile |grep fileyouwant， tar zxvf yourtarfile fileyouwant(copy上面的全路径用绝对路径)\ntar负责打包，gzip负责压缩 tar -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件\n这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。\n-z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出\n","permalink":"https://zpc2222.github.io/posts/tools/linux/","summary":"Shell命令 添加用户 useradd -d /home/zpc -m zpc 查看端口是否开放 /sbin/iptables -L -n 开端口 firewall-cmd \u0026ndash;zone=public \u0026ndash;add-port=81/tcp \u0026ndash;permanent 重启防火墙 systemctl restart firewalld.service 查看端口 firewall-cmd \u0026ndash;list-ports 安装JKD wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz 安装jdk17 1 2 3 4 5 6 7 8","title":"Linux"},{"content":"Windows10/11系统\n常用工具 编程工具：IEDA(Java)，MobaXterm(SSH+FTP)，Apifox(国内版postman)，Git(代码，文档管理)\nidea插件：mybatisX，Power Mode ||，Rainbow Brankets，SequenceDiagram，GitToolBox\n知识管理：Obsidian \u0026amp; 有道云笔记\n图像管理：PicGo 图床 ~~\u0026amp; Google 相册 ~~\n文本比较：Beyond Compare\n网盘同步：坚果云，阿里网盘，百度云盘\n系统日常 浏览器：Edge \u0026amp; Firefox(提交代码)\n输入法：搜狗\n通讯：微信 \u0026amp; 企业微信\n下载：Aria2 \u0026amp; IDM \u0026amp; Kinhdown(百度云解析)\n低频工具 爬虫监测：OpenWebMonitor \u0026amp; spider-flow\n翻译词典：DeepL \u0026amp; GoldenDict \u0026amp; 欧陆词典 \u0026amp; 有道词典 \u0026amp; QTranslate \u0026amp; Lingoes\n远程管理：ToDesk \u0026amp; AnyDesk \u0026amp; Teamviewer \u0026amp; Remote Utilities \u0026amp; XT800\n卸载清理：IObit Uninstaller \u0026amp; Glary Utilities(注册表清理) \u0026amp; Geek Uninstaller\n偶尔使用：VeraCrypt(本地加密)、Recuva(文件恢复)、12306Bypass、爱思助手、Bluestacks(安卓模拟器)、微 PE 工具箱、傲梅分区\nDockIt：主显示屏中，非全屏状态下，快速将窗口局部化。如何默认不全屏；应用不自动吸边？\nWechatExporter：微信记录导出，仅限 iOS 手机。安卓和 PC 端微信都加密，无法导出查看。\nSmartTubeNext：电视盒子上的去广告版 tube\nIDEA插件 插件名 功能 mybatisX 直接跳转到对面的xml中 Power Mode 忘了 Rainbow Brankets + 大括号明显 SequenceDiagram 接口流程图 GitToolBox git日志随时看 ","permalink":"https://zpc2222.github.io/posts/tools/applist/","summary":"Windows10/11系统 常用工具 编程工具：IEDA(Java)，MobaXterm(SSH+FTP)，Apifox(国内版postman","title":"必备应用"},{"content":"关于本站，及我\n本站：\nhugo发布的next主题的静态网站，曾使用过jekyll、hexo。最后发现了hugo这个宝藏！\nJekyll使用ruby编写，有github支持，可以将markdown文件直接放到git仓库，github会自动生成网页文件。（Github一直是一个亲ruby的社区） Hexo使用nodejs，提供了方便的部署命令，可以做到一条命令部署到github上。 Hugo使用go语言是一种编译型语言，速度非常快，官方文档写的非常好，部署简洁。前两者部署时需要安装很多依赖，而hugo可以直接提供二进制文件运行，甚至不需要root权限。 我：\n一名Java程序员,爱研究，爱学习，爱探究新的技术！\n前三年：以前端的身份入职中软国际，未转正前转为测试，参与多个项目，从页面测试，黑盒测试，慢慢到后端及白盒测试，后期基本都是使用Java进行代码测试！ 中三年：写了一年的testNG用例后，干脆还是做开发了，就这样又回到了开发岗位上，发现做技术，比打交道，要轻松的多了 后三年：正在进行中，学习新技术，学习架构中！ 网名: 藏锋 职业: 程序员 爱好: 溜达、爬山、养龟养鱼养花草 联系方式 请看主页 ","permalink":"https://zpc2222.github.io/about/","summary":"关于本站，及我 本站： hugo发布的next主题的静态网站，曾使用过jekyll、hexo。最后发现了hugo这个宝藏！ Jekyll使用rub","title":"🙋🏻‍♂️关于"},{"content":"微信支付 框架为springboot，需要在小程序的后端服务中，使用接微信支付； 在网上选择了很多的技术选型，发现如果是自己封装，一个是太繁琐，还有就是不方便维护，发现一个比较好的springboot包。\n官网地址：‘Document (notfound403.github.io)’\nSpring boot依赖包 pom引用 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.felord\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;payment-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 导入之后，可以直接引用\n但是建议直接用别的依赖，如果人家停止维护了，还得重新搞一遍，可以学习下人家的源码，自己封装了下，对接微信支付V3的大部分SDK了\n源码地址 GitHub：GitHub - NotFound403/payment-spring-boot: 微信支付V3，微信优惠券，代金券、公众号支付、微信小程序支付、分账、支付分、商家券\n封装后引用与直接引用效果是一样的\n实现: 1. 预置条件 1.申请商户号 2.绑定小程序与商户号 3.在商户号里，生成V3的密钥（V1,V2不要用了，太老了） 4.下载p12证书，并导入到项目中` P12证书导入，编译可能不会成功，需要在pom里面加下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-resources\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-resources\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/maven-archiver/resources\u0026lt;/outputDirectory\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;/src/main/resources/profile-${profile.active}\u0026lt;/directory\u0026gt; \u0026lt;include\u0026gt;application.yml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;application-${profile.active}.yml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;log4j2-${profile.active}.xml\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;bootstrap-${profile.active}.properties\u0026lt;/include\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;!-- 过滤后缀为pem、pfx的证书文件 --\u0026gt; \u0026lt;nonFilteredFileExtensions\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pem\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pfx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;p12\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;/nonFilteredFileExtensions\u0026gt; \u0026lt;/configuration\u0026gt;\u0026lt;/plugin\u0026gt; 2. 添加到工程的yaml配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 wechat: applets: # 小程序的配置项 openidUrl: https://api.weixin.qq.com/sns/jscode2session appid: appid secret: secret pay: #微信支付配置项 v3: # 微信小程序租户标识为 applets applets: # 应用appId 必填 app-id: appid # api v3 密钥 必填 app-v3-secret: v3secret # 微信支付商户号 必填 mch-id: 1234567 # 商户服务器域名 用于回调 回调路径为 domain + notifyUrl 需要放开回调接口的安全策略 必填 domain: https://xxx/app # 商户 api 证书路径 必填 填写classpath路径 位于 maven项目的resources文件下 cert-path: apiclient_cert.p12 3. 支付 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private final WechatApiProvider wechatApiProvider; OrderInfo orderInfo=XXx String ipAddr = getLocalIp(); // 定义附加数据 Map\u0026lt;String, Object\u0026gt; attach = new HashMap\u0026lt;\u0026gt;(); attach.put(\u0026#34;userId\u0026#34;, orderInfo.getUserId()); attach.put(\u0026#34;leaveComment\u0026#34;, orderInfo.getLeaveComment()); PayParams payParams = new PayParams(); // 商品描述,必填 payParams.setDescription(DESC); // 商户侧唯一订单号 建议为商户侧支付订单号 订单表主键 或者唯一标识字段 payParams.setOutTradeNo(orderInfo.getOrderId().toString()); payParams.setAttach(JSONObject.toJSONString(attach)); // 需要定义回调通知 payParams.setNotifyUrl(NOTIFY_URL); Amount amount = new Amount(); //付款金额单位为“分” amount.setTotal(orderInfo.getTotalPrice().intValue()); payParams.setAmount(amount); // 此类支付Payer必传,且openid需要同appid有绑定关系 具体去看文档 Payer payer = new Payer(); payer.setOpenid(openId); payParams.setPayer(payer); //支付场景描述 SceneInfo sceneInfo = new SceneInfo(); //用户终端IP sceneInfo.setPayerClientIp(ipAddr); if (orderInfo.getChargePileId() != null) { sceneInfo.setDeviceId(orderInfo.getChargePileId().toString()); } payParams.setSceneInfo(sceneInfo); wechatApiProvider.directPayApi(TENANT_ID).jsPay(payParams).getBody(); 4.支付回调： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 wechatApiProvider.callback(TENANT_ID).transactionCallback(params, data -\u0026gt; { Long orderId = Long.valueOf(data.getOutTradeNo()); OrderInfo orderInfo = orderInfoMapper.selectById(orderId); if (orderInfo == null) { log.error(\u0026#34;订单不存在，回调异常\u0026#34;); } if (UNPAID.getCode() != orderInfo.getStatus()) { log.error(\u0026#34;订单状态为[{}]，非未支付，回调异常\u0026#34;, orderInfo.getStatus()); } orderService.updateOrderStatus(orderId, PAID, OrderInfoVO.builder().payMethod(WXPAY.getCode()).build()); log.info(\u0026#34;订单状态刷新：orderId={}\u0026#34;, orderId); PayRecord payRecord = new PayRecord(); payRecord.setPayMerchantid(data.getMchid()); payRecord.setPayPrice(data.getAmount().getTotal()); payRecord.setOrderId(orderId); payRecord.setType(1); saveRecord(payRecord, 1); log.info(\u0026#34;支付记录保存：{}\u0026#34;, payRecord); }); 5.退款： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 RefundParams refundParams = new RefundParams(); RefundParams.RefundAmount amount = new RefundParams.RefundAmount(); amount.setRefund(paymentRefund.getRefundAmount()); amount.setTotal(paymentRefund.getActualAmount()); refundParams.setAmount(amount); refundParams.setOutRefundNo(REFUND + paymentRefund.getOutTradeNo()); refundParams.setNotifyUrl(NOTIFY_REFUND_URL); refundParams.setOutTradeNo(paymentRefund.getOutTradeNo()); refundParams.setReason(paymentRefund.getReason()); List\u0026lt;RefundGoodsDetail\u0026gt; goodsDetail = new ArrayList\u0026lt;\u0026gt;(); RefundGoodsDetail detail = new RefundGoodsDetail(); detail.setMerchantGoodsId(paymentRefund.getMerchantGoodsId()); detail.setGoodsName(paymentRefund.getGoodsName()); //数量写死1，商品单价金额等于总退款金额 detail.setUnitPrice(paymentRefund.getRefundAmount()); detail.setRefundQuantity(1); detail.setRefundAmount(paymentRefund.getRefundAmount()); goodsDetail.add(detail); refundParams.setGoodsDetail(goodsDetail); wechatApiProvider.directPayApi(TENANT_ID).refund(refundParams).getBody(); 6.退款回调: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 wechatApiProvider.callback(TENANT_ID).refundCallback(params, data -\u0026gt; { log.info(\u0026#34;退款回调：data={}\u0026#34;, data); Long orderId = Long.valueOf(data.getOutTradeNo()); OrderInfo orderInfo = orderInfoMapper.selectById(orderId); if (orderInfo == null) { log.error(\u0026#34;订单[{}]不存在，退款回调异常\u0026#34;, orderId); } if (PAID.getCode() != orderInfo.getStatus()) { log.error(\u0026#34;订单[{}]状态为[{}]，非已支付，请检查订单状态是否准确\u0026#34;, orderId, orderInfo.getStatus()); return; } orderService.updateOrderStatus(orderId, Constant.OrderStatus.REFUNDED, OrderInfoVO.builder().payMethod(WXPAY.getCode()).build()); log.info(\u0026#34;订单状态刷新：orderId={}\u0026#34;, orderId); PayRecord payRecord = new PayRecord(); payRecord.setPayMerchantid(data.getMchid()); payRecord.setPayPrice(data.getAmount().getPayerRefund()); payRecord.setOrderId(orderId); payRecord.setType(2); saveRecord(payRecord, 2); log.info(\u0026#34;支付记录保存：{}\u0026#34;, payRecord); }); 如上包含了基本支付的一套流程了，还有其他如账单下载，订单查询，关闭订单，积分支付，合并支付等复杂的接口，可以自己研究，封装类里面都已经包含了\n","permalink":"https://zpc2222.github.io/posts/tech/java/wechatpay/","summary":"微信支付 框架为springboot，需要在小程序的后端服务中，使用接微信支付； 在网上选择了很多的技术选型，发现如果是自己封装，一个是太繁琐，","title":"springboot接入微信支付"},{"content":"微信小程序相关 小程序地址\n1.登陆 获取openid方法，通过页面获取的jsCode，加上appid，秘钥，通过get方式获取\n1 2 3 4 5 6 7 8 OPENID_URL=\u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;; Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(8); map.put(\u0026#34;appid\u0026#34;, APPID); map.put(\u0026#34;secret\u0026#34;, SECRET); map.put(\u0026#34;js_code\u0026#34;, wechatUser.getJsCode()); map.put(\u0026#34;grant_type\u0026#34;, \u0026#34;authorization_code\u0026#34;); String resultJson = HttpClients.get(OPENID_URL, map); accessToken获取方法： 也是通过get方法，url不同,获取得到access_token跟expires_in（2小时默认）\n1 2 String url = TOKEN_URL + \u0026#34;?grant_type=client_credential\u0026amp;appid=\u0026#34; + APP_ID + \u0026#34;\u0026amp;secret=\u0026#34; + APP_SECRET; String resultJson = HttpClients.get(url) 3.订阅消息 接口说明： subscribeMessage.send | 微信开放文档 (qq.com)\n前提： 登陆小程序，创建好模板 获取模板id，字段\ndata中的类型，都以String类型存进去\nJava实现，具体字段参考上面的文档：\n1 2 3 4 String SUBSCRIBE_URL = \u0026#34;https://api.weixin.qq.com/cgi-bin/message/subscribe/send\u0026#34;; String url = SUBSCRIBE_URL + \u0026#34;?access_token=\u0026#34; + token; RequestBody body = RequestBody.create(JSON, Jsons.toJson(subMsg)); String resultJson = HttpClients.post(url, body); 可以用postman发送如下的，进行验证(access_token需要替换，touser必须要是该apiiid下生成的，并且已经在小程序端订阅了消息)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 post发送模板 https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=60_1LE2Afo9K2mvUGh-Oe_SKxKrA8_8HGKZhdg1wgtOj0oq_TI07E883H4ddCqkwtSn53OsKI4gqvj0YIle0RdwE_dwjy-ttci6nuDkH7Ja0zbJmsBa_FL-6lgtYsRZef9fWrNEF5-YgcsIPnd8KALiAGAYOZ { \u0026#34;touser\u0026#34;: \u0026#34;oEeL85FWxlG4HJU2eShtLMtWivoM\u0026#34;, \u0026#34;template_id\u0026#34;: \u0026#34;dgiozsRsVCqppuesQHJV5NZW5inmHf5bcNH5C74rglE\u0026#34;, \u0026#34;page\u0026#34;:\u0026#34;/pages/login/index\u0026#34;, \u0026#34;lang\u0026#34;:\u0026#34;zh_CN\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;character_string5\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;12312312333\u0026#34; }, \u0026#34;number13\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;11\u0026#34; }, \u0026#34;amount6\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;66\u0026#34; } , \u0026#34;time3\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;2022年08月22日\u0026#34; }, \u0026#34;thing7\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;充电结束啦\u0026#34; } } } ","permalink":"https://zpc2222.github.io/posts/tech/java/wechat-mini-program/","summary":"微信小程序相关 小程序地址 1.登陆 获取openid方法，通过页面获取的jsCode，加上appid，秘钥，通过get方式获取 1 2 3 4 5 6 7 8 OPENID_URL=\u0026#34;https://api.weixin.qq.com/sns/jscode2session\u0026#34;;","title":"微信小程序相关"},{"content":"cron表达式 （cron = \u0026ldquo;* * * * * *\u0026rdquo;)\ncron表达式格式： {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}\n例 \u0026ldquo;0 0 12 ? * WED\u0026rdquo; 在每星期三下午12:00 执行（年份通常 省略） 0 0/10 * * * ? 10分钟一次 */5 * * * * ? 每隔5秒执行一次 0 */1 * * * ? 每隔1分钟执行一次 0 0 5-15 * * ? 每天5-15点整点触发 0 0/3 * * * ? 每三分钟触发一次 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点\n0 0 12 ? * WED 表示每个星期三中午12点 0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 0 23 L * ? 每月最后一天23点执行一次 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 * * ? 2005 2005年的每天上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发\n\u0026ldquo;30 * * * * ?\u0026rdquo; 每半分钟触发任务 \u0026ldquo;30 10 * * * ?\u0026rdquo; 每小时的10分30秒触发任务 \u0026ldquo;30 10 1 * * ?\u0026rdquo; 每天1点10分30秒触发任务 \u0026ldquo;30 10 1 20 * ?\u0026rdquo; 每月20号1点10分30秒触发任务 \u0026ldquo;30 10 1 20 10 ? *\u0026rdquo; 每年10月20号1点10分30秒触发任务 \u0026ldquo;30 10 1 20 10 ? 2011\u0026rdquo; 2011年10月20号1点10分30秒触发任务 \u0026ldquo;30 10 1 ? 10 * 2011\u0026rdquo; 2011年10月每天1点10分30秒触发任务 \u0026ldquo;30 10 1 ? 10 SUN 2011\u0026rdquo; 2011年10月每周日1点10分30秒触发任务 \u0026ldquo;15,30,45 * * * * ?\u0026rdquo; 每15秒，30秒，45秒时触发任务 \u0026ldquo;15-45 * * * * ?\u0026rdquo; 15到45秒内，每秒都触发任务 \u0026ldquo;15/5 * * * * ?\u0026rdquo; 每分钟的每15秒开始触发，每隔5秒触发一次 \u0026ldquo;15-30/5 * * * * ?\u0026rdquo; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次 \u0026ldquo;0 0/3 * * * ?\u0026rdquo; 每小时的第0分0秒开始，每三分钟触发一次 \u0026ldquo;0 15 10 ? * MON-FRI\u0026rdquo; 星期一到星期五的10点15分0秒触发任务 \u0026ldquo;0 15 10 L * ?\u0026rdquo; 每个月最后一天的10点15分0秒触发任务 \u0026ldquo;0 15 10 LW * ?\u0026rdquo; 每个月最后一个工作日的10点15分0秒触发任务 \u0026ldquo;0 15 10 ? * 5L\u0026rdquo; 每个月最后一个星期四的10点15分0秒触发任务 \u0026ldquo;0 15 10 ? * 5#3\u0026rdquo; 每个月第三周的星期四的10点15分0秒触发任务\n","permalink":"https://zpc2222.github.io/posts/tech/cron-expression/","summary":"cron表达式 （cron = \u0026ldquo;* * * * * *\u0026rdquo;) cron表达式格式： {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 例 \u0026ldquo;0 0 12 ? * WED\u0026rdquo; 在","title":"cron表达式"},{"content":"IP查询的一些方法 IP_URL = \u0026ldquo;http://whois.pconline.com.cn/ipJson.jsp?ip=%s\u0026amp;json=true\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 /** * 获取ip地址 */ public static String getIp(HttpServletRequest request) { String ip = request.getHeader(\u0026#34;x-forwarded-for\u0026#34;); if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;WL-Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) { ip = request.getRemoteAddr(); } String comma = \u0026#34;,\u0026#34;; String localhost = \u0026#34;127.0.0.1\u0026#34;; if (ip.contains(comma)) { ip = ip.split(\u0026#34;,\u0026#34;)[0]; } if (localhost.equals(ip)) { // 获取本机真正的ip地址 try { ip = InetAddress.getLocalHost().getHostAddress(); } catch (UnknownHostException e) { e.printStackTrace(); } } return ip; } /** * 根据ip获取详细地址 */ public static String getCityInfo(String ip) { String api = String.format(IP_URL, ip); JSONObject object = JSONUtil.parseObj(HttpUtil.get(api)); return object.get(\u0026#34;addr\u0026#34;, String.class); } /** * 获得当天是周几 */ public static String getWeekDay() { String[] weekDays = {\u0026#34;Sun\u0026#34;, \u0026#34;Mon\u0026#34;, \u0026#34;Tue\u0026#34;, \u0026#34;Wed\u0026#34;, \u0026#34;Thu\u0026#34;, \u0026#34;Fri\u0026#34;, \u0026#34;Sat\u0026#34;}; Calendar cal = Calendar.getInstance(); cal.setTime(new Date()); int w = cal.get(Calendar.DAY_OF_WEEK) - 1; if (w \u0026lt; 0) { w = 0; } return weekDays[w]; } public static String getBrowser(HttpServletRequest request) { UserAgent userAgent = UserAgent.parseUserAgentString(request.getHeader(\u0026#34;User-Agent\u0026#34;)); Browser browser = userAgent.getBrowser(); return browser.getName(); } /** * 导出excel */public static void downloadExcel(List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list, HttpServletResponse response) throws IOException { String tempPath = System.getProperty(\u0026#34;java.io.tmpdir\u0026#34;) + IdUtil.fastSimpleUUID() + \u0026#34;.xlsx\u0026#34;; File file = new File(tempPath); BigExcelWriter writer = ExcelUtil.getBigWriter(file); // 一次性写出内容，使用默认样式，强制输出标题 writer.write(list, true); //response为HttpServletResponse对象 response.setContentType(\u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8\u0026#34;); //test.xls是弹出下载对话框的文件名，不能为中文，中文请自行编码 response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=file.xlsx\u0026#34;); ServletOutputStream out = response.getOutputStream(); // 终止后删除临时文件 file.deleteOnExit(); writer.flush(out, true); //此处记得关闭输出Servlet流 IoUtil.close(out); } /** * 将文件名解析成文件的上传路径 */ public static File upload(MultipartFile file, String filePath) { String suffix = getExtensionName(file.getOriginalFilename()); StringBuffer nowStr = fileRename(); try { String fileName = nowStr + \u0026#34;.\u0026#34; + suffix; String path = filePath + fileName; // getCanonicalFile 可解析正确各种路径 File dest = new File(path).getCanonicalFile(); // 检测是否存在目录 if (!dest.getParentFile().exists()) { dest.getParentFile().mkdirs(); } // 文件写入 file.transferTo(dest); return dest; } catch (Exception e) { e.printStackTrace(); } return null; } /** * MultipartFile转File */public static File toFile(MultipartFile multipartFile) { // 获取文件名 String fileName = multipartFile.getOriginalFilename(); // 获取文件后缀 String prefix = \u0026#34;.\u0026#34; + getExtensionName(fileName); File file = null; try { // 用uuid作为文件名，防止生成的临时文件重复 file = File.createTempFile(IdUtil.simpleUUID(), prefix); // MultipartFile to File multipartFile.transferTo(file); } catch (IOException e) { e.printStackTrace(); } return file; } /** * 获取文件扩展名，不带 . */public static String getExtensionName(String filename) { if ((filename != null) \u0026amp;\u0026amp; (filename.length() \u0026gt; 0)) { int dot = filename.lastIndexOf(\u0026#39;.\u0026#39;); if ((dot \u0026gt; -1) \u0026amp;\u0026amp; (dot \u0026lt; (filename.length() - 1))) { return filename.substring(dot + 1); } } return filename; } public static String getFileType(String type) { String documents = \u0026#34;txt doc pdf ppt pps xlsx xls docx\u0026#34;; String music = \u0026#34;mp3 wav wma mpa ram ra aac aif m4a\u0026#34;; String video = \u0026#34;avi mpg mpe mpeg asf wmv mov qt rm mp4 flv m4v webm ogv ogg\u0026#34;; String image = \u0026#34;bmp dib pcp dif wmf gif jpg tif eps psd cdr iff tga pcd mpt png jpeg\u0026#34;; if (image.contains(type)) { return \u0026#34;pic\u0026#34;; } else if (documents.contains(type)) { return \u0026#34;txt\u0026#34;; } else if (music.contains(type)) { return \u0026#34;music\u0026#34;; } else if (video.contains(type)) { return \u0026#34;vedio\u0026#34;; } else { return \u0026#34;other\u0026#34;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 package com.ruoyi.common.core.utils.ip; import java.net.InetAddress; import java.net.UnknownHostException; import javax.servlet.http.HttpServletRequest; import com.ruoyi.common.core.utils.StringUtils; /** * 获取IP方法 * * @author zpc */public class IpUtils { /** * 获取客户端IP ** @param request 请求对象 * @return IP地址 */ public static String getIpAddr(HttpServletRequest request) { if (request == null) { return \u0026#34;unknown\u0026#34;; } String ip = request.getHeader(\u0026#34;x-forwarded-for\u0026#34;); if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;X-Forwarded-For\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;WL-Proxy-Client-IP\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getHeader(\u0026#34;X-Real-IP\u0026#34;); } if (ip == null || ip.length() == 0 || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(ip)) { ip = request.getRemoteAddr(); } return \u0026#34;0:0:0:0:0:0:0:1\u0026#34;.equals(ip) ? \u0026#34;127.0.0.1\u0026#34; : getMultistageReverseProxyIp(ip); } /** * 检查是否为内部IP地址 * * @param ip IP地址 * @return 结果 */ public static boolean internalIp(String ip) { byte[] addr = textToNumericFormatV4(ip); return internalIp(addr) || \u0026#34;127.0.0.1\u0026#34;.equals(ip); } /** * 检查是否为内部IP地址 * * @param addr byte地址 * @return 结果 */ private static boolean internalIp(byte[] addr) { if (StringUtils.isNull(addr) || addr.length \u0026lt; 2) { return true; } final byte b0 = addr[0]; final byte b1 = addr[1]; // 10.x.x.x/8 final byte SECTION_1 = 0x0A; // 172.16.x.x/12 final byte SECTION_2 = (byte) 0xAC; final byte SECTION_3 = (byte) 0x10; final byte SECTION_4 = (byte) 0x1F; // 192.168.x.x/16 final byte SECTION_5 = (byte) 0xC0; final byte SECTION_6 = (byte) 0xA8; switch (b0) { case SECTION_1: return true; case SECTION_2: if (b1 \u0026gt;= SECTION_3 \u0026amp;\u0026amp; b1 \u0026lt;= SECTION_4) { return true; } case SECTION_5: switch (b1) { case SECTION_6: return true; } default: return false; } } /** * 将IPv4地址转换成字节 * * @param text IPv4地址 * @return byte 字节 */ public static byte[] textToNumericFormatV4(String text) { if (text.length() == 0) { return null; } byte[] bytes = new byte[4]; String[] elements = text.split(\u0026#34;\\\\.\u0026#34;, -1); try { long l; int i; switch (elements.length) { case 1: l = Long.parseLong(elements[0]); if ((l \u0026lt; 0L) || (l \u0026gt; 4294967295L)) { return null; } bytes[0] = (byte) (int) (l \u0026gt;\u0026gt; 24 \u0026amp; 0xFF); bytes[1] = (byte) (int) ((l \u0026amp; 0xFFFFFF) \u0026gt;\u0026gt; 16 \u0026amp; 0xFF); bytes[2] = (byte) (int) ((l \u0026amp; 0xFFFF) \u0026gt;\u0026gt; 8 \u0026amp; 0xFF); bytes[3] = (byte) (int) (l \u0026amp; 0xFF); break; case 2: l = Integer.parseInt(elements[0]); if ((l \u0026lt; 0L) || (l \u0026gt; 255L)) { return null; } bytes[0] = (byte) (int) (l \u0026amp; 0xFF); l = Integer.parseInt(elements[1]); if ((l \u0026lt; 0L) || (l \u0026gt; 16777215L)) { return null; } bytes[1] = (byte) (int) (l \u0026gt;\u0026gt; 16 \u0026amp; 0xFF); bytes[2] = (byte) (int) ((l \u0026amp; 0xFFFF) \u0026gt;\u0026gt; 8 \u0026amp; 0xFF); bytes[3] = (byte) (int) (l \u0026amp; 0xFF); break; case 3: for (i = 0; i \u0026lt; 2; ++i) { l = Integer.parseInt(elements[i]); if ((l \u0026lt; 0L) || (l \u0026gt; 255L)) { return null; } bytes[i] = (byte) (int) (l \u0026amp; 0xFF); } l = Integer.parseInt(elements[2]); if ((l \u0026lt; 0L) || (l \u0026gt; 65535L)) { return null; } bytes[2] = (byte) (int) (l \u0026gt;\u0026gt; 8 \u0026amp; 0xFF); bytes[3] = (byte) (int) (l \u0026amp; 0xFF); break; case 4: for (i = 0; i \u0026lt; 4; ++i) { l = Integer.parseInt(elements[i]); if ((l \u0026lt; 0L) || (l \u0026gt; 255L)) { return null; } bytes[i] = (byte) (int) (l \u0026amp; 0xFF); } break; default: return null; } } catch (NumberFormatException e) { return null; } return bytes; } /** * 获取IP地址 * * @return 本地IP地址 */ public static String getHostIp() { try { return InetAddress.getLocalHost().getHostAddress(); } catch (UnknownHostException e) { } return \u0026#34;127.0.0.1\u0026#34;; } /** * 获取主机名 * * @return 本地主机名 */ public static String getHostName() { try { return InetAddress.getLocalHost().getHostName(); } catch (UnknownHostException e) { } return \u0026#34;未知\u0026#34;; } /** * 从多级反向代理中获得第一个非unknown IP地址 * * @param ip 获得的IP地址 * @return 第一个非unknown IP地址 */ public static String getMultistageReverseProxyIp(String ip) { // 多级反向代理检测 if (ip != null \u0026amp;\u0026amp; ip.indexOf(\u0026#34;,\u0026#34;) \u0026gt; 0) { final String[] ips = ip.trim().split(\u0026#34;,\u0026#34;); for (String subIp : ips) { if (false == isUnknown(subIp)) { ip = subIp; break; } } } return ip; } /** * 检测给定字符串是否为未知，多用于检测HTTP请求相关 * * @param checkString 被检测的字符串 * @return 是否未知 */ public static boolean isUnknown(String checkString) { return StringUtils.isBlank(checkString) || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(checkString); } } 文件流上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 long begin=System.currentTimeMillis(); InputStream fis=multipartFile.getInputStream(); dest = new File(newFileName); FileOutputStream fos=new FileOutputStream(dest); //先定义一个字节缓冲区，减少I/O次数，提高读写效率 byte[] buffer=new byte[10240]; int size=0; while((size=fis.read(buffer))!=-1){ fos.write(buffer, 0, size); } fis.close(); fos.close(); long end=System.currentTimeMillis(); log.info(\u0026#34;使用文件输入流和文件输出流实现文件的复制完毕！耗时：{} 毫秒\u0026#34;,(end-begin)); COS文件上传 ","permalink":"https://zpc2222.github.io/posts/tech/java/java-common-utils/","summary":"IP查询的一些方法 IP_URL = \u0026ldquo;http://whois.pconline.com.cn/ipJson.jsp?ip=%s\u0026amp;json=true\u0026quot; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58","title":"Java常用工具类"},{"content":"JVM分析 参数 1 2 3 4 5 6 7 8 9 10 11 -Xms、-Xmn 堆内存分配： JVM初始分配的内存由-Xms指定，默认是物理内存的1/64 JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4 默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。 因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。 非堆内存分配： JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64； 由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。 -Xmn2G：设置年轻代大小为2G。 -XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。 命令 jinfo（查看/修改虚拟机参数）\njmap命令是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。 打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。 jmap -J-d64 -heap 12105 jmap -heap 19570 -heap 打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况. jmap -histo 24107 打印每个class的实例数目,内存占用,类全名信息. VM的内部类名字开头会加上前缀 * 如果live子参数加上后,只统计活的对象数量。 jmap -histo pid\u0026gt;a.log 日志将其保存，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。\n1 2 using parallel threads in the new generation. ##新生代采用的是并行线程处理方式 垃圾回收统计：jstat -gc 进程id S0C：第一个幸存区的大小 S1C：第二个幸存区的大小 S0U：第一个幸存区的使用大小 S1U：第二个幸存区的使用大小 EC：伊甸园区的大小 EU：伊甸园区的使用大小 OC：老年代大小 OU：老年代使用大小 MC：方法区大小 MU：方法区使用大小 CCSC:压缩类空间大小 CCSU:压缩类空间使用大小 YGC：年轻代垃圾回收次数 YGCT：年轻代垃圾回收消耗时间 FGC：老年代垃圾回收次数 FGCT：老年代垃圾回收消耗时间 GCT：垃圾回收消耗总时间\n堆内存统计：jstat -gccapacity 进程id NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 EC：伊甸园区的大小 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC:当前老年代大小 MCMN:最小元数据容量 MCMX：最大元数据容量 MC：当前元数据空间大小 CCSMN：最小压缩类空间大小 CCSMX：最大压缩类空间大小 CCSC：当前压缩类空间大小 YGC：年轻代gc次数 FGC：老年代GC次数\n","permalink":"https://zpc2222.github.io/posts/tech/java/jvm-analysis/","summary":"JVM分析 参数 1 2 3 4 5 6 7 8 9 10 11 -Xms、-Xmn 堆内存分配： JVM初始分配的内存由-Xms指定，默认是物理内存的1/64 JVM最大分配","title":"JVM分析"},{"content":"将本地的jar上传至私服：\n1 mvn deploy:deploy-file --settings=D:\\java\\apache-maven-3.8.6\\conf\\settings.xml -DgroupId=cmbc.sdk -DartifactId=SADK-CMBC -Dversion=3.1.0.8-SNAPSHOT -Dpackaging=jar -Dfile=D:\\javaDemo\\lib\\SADK-CMBC-3.1.0.8.jar -DrepositoryId=releases -Durl=http://192.168.1.1:8081/repository/maven-snapshots 推送到仓库 mvn deploy:deploy-file -Dfile=xxx-web\\target\\radp-web-1.0.jar -DgroupId=com.richisland.radp -DartifactId=radp-web -Dversion=1.0 -Dpackaging=jar -DrepositoryId=fd-release –Durl=http://xxx.com/repository/release/\n推送zip包\nmvn deploy:deploy-file -Dfile=package.zip -DgroupId=xxx -DartifactId=package -Dversion=1.1 -Dpackaging=zip -DrepositoryId=fd-release –Durl=http://xxx.com/repository/release/\n流水线推送\nmvn deploy:deploy-file -Dfile=E:\\package.tar.gz -DgroupId=xxx -DartifactId=pipelining -Dversion=1.1 -Dpackaging=gz -DrepositoryId=fd-release –Durl=http://xxx.com/repository/release/\n","permalink":"https://zpc2222.github.io/posts/tech/maven/","summary":"将本地的jar上传至私服： 1 mvn deploy:deploy-file --settings=D:\\java\\apache-maven-3.8.6\\conf\\settings.xml -DgroupId=cmbc.sdk -DartifactId=SADK-CMBC -Dversion=3.1.0.8-SNAPSHOT -Dpackaging=jar -Dfile=D:\\javaDemo\\lib\\SADK-CMBC-3.1.0.8.jar -DrepositoryId=releases -Durl=http://192.168.1.1:8081/repository/maven-snapshots 推送到仓库 mvn deploy:deploy-file -Dfile=xxx-web\\target\\radp-web-1.0.jar -DgroupId=com.richisland.radp -DartifactId=radp-web -Dversion=1.0 -Dpackaging=jar -DrepositoryId=fd-release –Durl=http://xxx.com/repository/r","title":"maven"},{"content":"概念 组件 名 概念 IO 流 各种各样的流（文件、数组、缓冲、管道。。。）的处理（输入输出） Channel 通道 代表一个连接，每个Client请对会对应到具体的一个Channel ChannelPipeline 责任链 每个Channel都有且仅有一个ChannelPipeline与之对应，里面是各种各样的Handler handler 事件 用于处理出入站消息及相应的事件，实现我们自己要的业务逻辑 EventLoopGroup I/O线程池 负责处理Channel对应的I/O事件 ChannelInitializer Channel初始化器 ChannelFuture 执行结果 代表I/O操作的执行结果，通过事件机制，获取执行结果，通过添加监听器，执行我们想要的操作 ByteBuf 字节序列 通过ByteBuf操作基础的字节数组和缓冲区 ServerBootstrap 服务器端启动辅助对象 Bootstrap 客户端启动辅助对象 流程图 客户端代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.util.CharsetUtil; @ChannelHandler.Sharable //这个注解是为了线程安全，如果你不在乎是否线程安全，不加也可以 public class ClientHandler extends SimpleChannelInboundHandler\u0026lt;ByteBuf\u0026gt; { //这里的类型可以是ByteBuf，也可以是String，还可以是对象，根据实际情况来 //channelRead0 消息读取方法，注意名称中有个0 //ChannelHandlerContext：通道上下文，代指Channel； //ByteBuf：字节序列，通过ByteBuf操作基础的字节数组和缓冲区，因为JDK原生操作字节麻烦、效率低，所以Netty对字节的操作进行了封装，实现了指数级的性能提升，同时使用更加便利； @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception { System.out.println(\u0026#34;接收到的消息：\u0026#34; + byteBuf.toString(CharsetUtil.UTF_8));//CharsetUtil.UTF_8：这个是JDK原生的方法，用于指定字节数组转换为字符串时的编码格式。 } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //出现异常的时候执行的动作（打印并关闭通道） System.out.println(\u0026#34;exceptionCaught:\u0026#34; + cause.toString()); if (\u0026#34;java.io.IOException: 远程主机强迫关闭了一个现有的连接。\u0026#34;.equals(cause.toString()) || \u0026#34;java.io.IOException: Connection reset by peer\u0026#34;.equals(cause.toString())) { System.out.println(\u0026#34;与服务端断联\u0026#34;); ctx.close().sync(); ctx.flush(); } } } 客户端启用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 import io.netty.bootstrap.Bootstrap; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.util.CharsetUtil; import java.net.InetSocketAddress; public class ClientStart { private final String host; private final int port; public ClientStart(String host, int port) { this.host = host; this.port = port; } public static void main(String[] args) throws Exception { new ClientStart(\u0026#34;192.168.20.125\u0026#34;, 8089).run(); } public void run() throws Exception { /** * @Description 配置相应的参数，提供连接到远端的方法 **/ EventLoopGroup group = new NioEventLoopGroup();//I/O线程池 try { Bootstrap bs = new Bootstrap();//客户端辅助启动类 bs.group(group).channel(NioSocketChannel.class)//实例化一个Channel .remoteAddress(new InetSocketAddress(host, port)).handler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;()//通道Channel的初始化工作，如加入多个handler，都在这里进行； { @Override protected void initChannel(SocketChannel socketChannel) throws Exception { /** * 连接建立后，都会自动创建一个管道pipeline，这个管道也被称为责任链，保证顺序执行，同时又可以灵活的配置各类Handler，这是一个很精妙的设计，既减少了线程切换带来的资源开销、避免好多麻烦事，同时性能又得到了极大增强。 */ socketChannel.pipeline().addLast(new ClientHandler());//添加我们自定义的Handler } }); //连接到远程节点；等待连接完成 ChannelFuture future = bs.connect().sync();//这里的sync()表示采用的同步方法，这样连接建立成功后，才继续往下执行； //发送消息到服务器端，编码格式是utf-8 future.channel().writeAndFlush(Unpooled.copiedBuffer(\u0026#34;Hello World\u0026#34;, CharsetUtil.UTF_8)); //阻塞操作，closeFuture()开启了一个channel的监听器（这期间channel在进行各项工作），直到链路断开 future.channel().closeFuture().sync(); } finally { group.shutdownGracefully().sync(); } } } 服务端实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; import io.netty.util.CharsetUtil; import io.netty.util.ReferenceCountUtil; import static java.lang.System.*; @ChannelHandler.Sharable public class ServerHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { //处理收到的数据，并反馈消息到到客户端 ByteBuf byteBuf = (ByteBuf) msg; byte[] bytes = new byte[byteBuf.readableBytes()]; byteBuf.readBytes(bytes); out.println(\u0026#34;收到客户端发过来的消息: \u0026#34; +new String(bytes, CharsetUtil.UTF_8)); //写入并发送信息到远端（客户端） ctx.writeAndFlush(Unpooled.copiedBuffer(\u0026#34;你好，我是服务端，我已经收到你发送的消息\u0026#34;, CharsetUtil.UTF_8)); // 引用计数器及时申请释放不再引用的对象 ReferenceCountUtil.release(byteBuf); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { //出现异常的时候执行的动作（打印并关闭通道） out.println(\u0026#34;exceptionCaught:\u0026#34; + cause.toString()); if (\u0026#34;java.io.IOException: 远程主机强迫关闭了一个现有的连接。\u0026#34;.equals(cause.toString()) || \u0026#34;java.io.IOException: Connection reset by peer\u0026#34;.equals(cause.toString())) { out.println(\u0026#34;ExceptionCaught: Client Disconnect The Connection.\u0026#34;); ctx.close().sync(); ctx.flush(); } } } 服务端启动: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import java.net.InetAddress; import java.net.InetSocketAddress; import java.net.NetworkInterface; import java.net.SocketException; import java.util.Enumeration; import java.util.LinkedList; import java.util.List; public class ServerStart { private final int port; public ServerStart(int port) { this.port = port; } public static void main(String[] args) throws Exception { new ServerStart(8089).run(); } /** * 创建两个EventLoopGroup的实例，一个负责接收客户端的连接，另一个负责处理消息I/O * @throws Exception */ public void run() throws Exception { String url = getIpAddress().get(0); InetSocketAddress address = new InetSocketAddress(url, port);//设置监听端口 //Netty的Reactor线程池，初始化了一个NioEventLoop数组，用来处理I/O操作,如接受新的连接和读/写数据 // 1.创建两个事件组,boss用于处理请求的accept事件,work用于请求的read和write事件 EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap();//用于启动NIO服务 b.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class) //通过工厂方法设计模式实例化一个channel .localAddress(address) .childHandler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { //ChannelInitializer是一个特殊的处理类，他的目的是帮助使用者配置一个新的Channel,用于把许多自定义的处理类增加到pipline上来 @Override public void initChannel(SocketChannel ch) throws Exception {//ChannelInitializer 是一个特殊的处理类，他的目的是帮助使用者配置一个新的 Channel。 ch.pipeline().addLast(new ServerHandler());//配置childHandler来通知一个关于消息处理的InfoServerHandler实例 } }); //绑定服务器，该实例将提供有关IO操作的结果或状态的信息 ChannelFuture channelFuture = b.bind(address).sync(); System.out.println(\u0026#34;在\u0026#34; + address + \u0026#34;上开启监听\u0026#34;); //阻塞操作，closeFuture()开启了一个channel的监听器（这期间channel在进行各项工作），直到链路断开 channelFuture.channel().closeFuture().sync(); } finally { bossGroup.shutdownGracefully().sync();//关闭EventLoopGroup并释放所有资源，包括所有创建的线程 workerGroup.shutdownGracefully().sync();//关闭EventLoopGroup并释放所有资源，包括所有创建的线程 } } private static List\u0026lt;String\u0026gt; getIpAddress() { List\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); try { for (Enumeration\u0026lt;NetworkInterface\u0026gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) { NetworkInterface intf = en.nextElement(); String name = intf.getName(); if (!name.contains(\u0026#34;docker\u0026#34;) \u0026amp;\u0026amp; !name.contains(\u0026#34;lo\u0026#34;)) { for (Enumeration\u0026lt;InetAddress\u0026gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) { InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) { String ipaddress = inetAddress.getHostAddress(); if (!ipaddress.contains(\u0026#34;::\u0026#34;) \u0026amp;\u0026amp; !ipaddress.contains(\u0026#34;0:0:\u0026#34;) \u0026amp;\u0026amp; !ipaddress.contains(\u0026#34;fe80\u0026#34;)) { list.add(ipaddress); } } } } } } catch (SocketException ex) { String ip = \u0026#34;127.0.0.1\u0026#34;; list.add(ip); } return list; } } ","permalink":"https://zpc2222.github.io/posts/tech/netty-in-action/","summary":"概念 组件 名 概念 IO 流 各种各样的流（文件、数组、缓冲、管道。。。）的处理（输入输出） Channel 通道 代表一个连接，每个Client请对会对应到具体的一个C","title":"Netty实战"},{"content":"Nginx的一些使用心得 常用命令 启动 1 2 3 4 5 进入nginx安装路径下执行start nginx 命令 /usr/sbin/nginx (nginx安装路径) service nginx start 停止 1 2 3 4 5 6 7 /usr/sbin/nginx -s stop nginx -s stop 命令 ps -ef|grep nginx pkill -9 nginx (强制停止) 重新载入配置/重启 1 2 3 4 5 6 7 sudo /usr/sbin/nginx -s stop ;sudo /usr/sbin/nginx nginx -s reload 进入nginx可执行目录sbin下，输入命令./nginx -s reload 查找当前nginx进程号，然后输入命令：kill -HUP 进程号 实现重启nginx服务 查看启动情况 1 ps -ef | grep nginx nginx检查配置 1 nginx -t 出现显示nginx.conf 即可\n配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 user www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## server { listen 80; server_name 192.168.1.100; client_max_body_size 200m; #上传文件的大小 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_send_timeout 180s; # 设置发送超时时间， proxy_read_timeout 180s; # 设置读取超时时间。 #web入口工程 location / { root /home/vue/dist; index index.html index.htm; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_ssl_session_reuse off; charset utf-8; } location /admin { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8081; } location /app { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } location /dashboard { proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:9080; } } include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } 根据上面的nginx配置文件,可以将nginx的配置分为以下的组成结构\n1 2 3 4 5 6 7 8 9 ... #全局快 events { #events快 } http{ #http块 server { #server快 location { #location快 } } } 每块的结构功能 (1)、全局块: 配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。\n(2)、events块: 配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接， 开启多个网络连接序列化等\n(3)、http块: 可以配置多个server,配置代理、缓存、日志定义等能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。\n(4)、server块: 配置虚拟主机的相关参数，一个http中可以有多个server。\n(5)、location块: 配置请求的路由，以及各种页面的处理情况。 配置文件中常用的变量,可以用于请求拦截或者匹配路由\n1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址； 2.$remote_user ：用来记录客户端用户名称； 3.$time_local ： 用来记录访问时间与时区； 4.$request ： 用来记录请求的url与http协议； 5.$status ： 用来记录请求状态；成功是200； 6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小； 7.$http_referer ：用来记录从那个页面链接访问过来的； 8.$http_user_agent ：记录客户端浏览器的相关信息；\n参数说明： 1、listen：nginx监听的端口 1、server_name：nginx服务的ip地址或者域名 3、location：配置路由访问信息\nlocation 配置参数： 1、 = ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求。 2、 ~：用于表示 uri 包含正则表达式，并且区分大小写。 3、 ~*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、 ^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location块中的正则 uri 和请求字符串做匹配。 注意：如果 uri 包含正则表达式，则必须要有~ 或者 ~*标识。\nproxy_pass带斜杠 proxy_pass末尾有斜杠 / ，proxy_pass不拼接location的路径\n1 2 3 location /api/ { proxy_pass http://127.0.0.1:8000/; } 请求地址：http://localhost/api/test 转发地址：http://127.0.0.1:8000/test proxy_pass末尾无斜杠 / ，proxy_pass会拼接location的路径\n1 2 3 location /api/ { proxy_pass http://127.0.0.1:8000; } 请求地址：http://localhost/api/test 转发地址：http://127.0.0.1:8000/api/test\n负载均衡 在 nginx 配置文件中进行负载均衡的配置\n在http中添加 upstream ，在upstream 中添加服务列表，设置负载均衡策略 在location 中指定upstream 名称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 http { ..... upstream myservere { server 192.168.10.196:8001 weight=1; server 192.168.10.196:8002 weight=5; } server { listen 9001; server_name localhost; location / { proxy_pass http://myservere/; } } } 负载均衡策略 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。\nweight weight 代表权重，默认为 1，权重越高被分配的客户端越多\n指定轮询几率， weight 和访问比率成正比，用于后端服务器性能不均的情况。 例如：\n1 2 3 4 upstream myservere { server 192.168.10.196:8001 weight=1; server 192.168.10.196:8002 weight=5; } ip_hash 每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 例如：\n1 2 3 4 5 upstream myservere { ip_hash; server 192.168.10.196:8001; server 192.168.10.196:8002; } fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n1 2 3 4 5 upstream myservere { server 192.168.10.196:8001; server 192.168.10.196:8002; fair; } tips Linux 服务器上防火墙会端口拦截，所以需要在防火墙中开放80 端口，也可以直接关闭防火墙，这儿提供允许80端口方法\n1 2 3 4 5 # 允许80端口 firewall-cmd --permanent --add-port=80/tcp --zone=public # 重新加载防火墙配置 firewall-cmd --reload ","permalink":"https://zpc2222.github.io/posts/tech/nginx/","summary":"Nginx的一些使用心得 常用命令 启动 1 2 3 4 5 进入nginx安装路径下执行start nginx 命令 /usr/sbin/nginx (nginx安装路径) service nginx start 停止 1 2 3 4 5 6 7 /usr/sbin/nginx","title":"Nginx"},{"content":"由此开始 - Obsidian 中文帮助 - Obsidian Publish\nObsidian是基于Markdown文件的本地知识管理软件，并且开发者承诺Obsidian对于个人使用者永久免费。\nMarkdown文件体积小、语法简单、便于迁移。相较于其他双向链接软件迁移后整个双向链接、网络关系崩溃，Obsidian是通过Markdown文件中的语法进行关联的，只需要复制粘贴Obsidian选中的库就可以轻松实现完整地迁移。（虽然配置和插件需要重新设置）\n","permalink":"https://zpc2222.github.io/posts/tools/obsidian/","summary":"由此开始 - Obsidian 中文帮助 - Obsidian Publish Obsidian是基于Markdown文件的本地知识管理软件，并且开发者承诺Obsidian对于个人使用者永久免费","title":"obsidian"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 1.启动nameserver nohup sh bin/mqnamesrv \u0026amp; #### 2.启动broker nohup sh bin/mqbroker -n 192.168.1.100:9876 -c conf/broker.conf autoCreateTopicEnable=true \u0026amp; ## 查看日志 tail -f ~/logs/rocketmqlogs/namesrv.log tail -f ~/logs/rocketmqlogs/broker.log 查看所有topic sh mqadmin topicList -n 192.168.1.100:9876 ## 1.关闭NameServer sh bin/mqshutdown namesrv ## 2.关闭Broker sh bin/mqshutdown broker ","permalink":"https://zpc2222.github.io/posts/tech/rocketmq/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 1.启动nameserver nohup sh bin/mqnamesrv \u0026amp; #### 2.启动broker nohup sh bin/mqbroker -n 192.168.1.100:9876 -c conf/broker.conf autoCreateTopicEnable=true \u0026amp; ## 查看日志 tail -f ~/logs/rocketmqlogs/namesrv.log tail -f ~/logs/rocketmqlogs/broker.log 查看所有t","title":"rocketMQ"},{"content":"shell启动脚本\n1 2 java -Xms1024m -Xmx1024m -Xmn512m -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:7665 -jar oc-app-test.jar \u0026amp; java -jar-Dnet.java.games.input.librarypath=/home/oc/oc-app-test -Xdebug-Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=*:7665/home/oc/oc-app-test/*.jar \u0026amp; nccloud启动脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/sh #根据端口号查询对应的pid #pid=$(netstat -nlp | grep :$port | awk \u0026#39;{print $7}\u0026#39; | awk -F\u0026#34;/\u0026#34; \u0026#39;{ print $1 }\u0026#39;); pid=$(ps -ef | grep \u0026#39;[j]ava -jar -Dnet.java.games.input.librarypath=/home/iom/nc-cloud\u0026#39; | awk \u0026#39;{print $2}\u0026#39;); #杀掉对应的进程，如果pid不存在，则不执行 if [ -n \u0026#34;$pid\u0026#34; ]; then kill $pid; sleep 2 fi java -jar -Dnet.java.games.input.librarypath=/home/iom/nc-cloud -Xdebug -Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=*:7666 /home/iom/nc-cloud/*.jar --spring.profiles.active=dev \u0026amp; Jenkins使用的shell脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #/bin/bash #前提：压缩包格式为appname-bin.tar.gz 解压出来的文件夹为appname 例如 app-dev-bin.tar.gz app-dev #下面appname配置要操作的应用名，例app-dev appname=app-dev echo starting kill $appname...... #grep -w 完全匹配关键字，打印对应进程名 pid=`ps -ef|grep -w $appname|grep java|awk \u0026#39;{printf $2}\u0026#39;` echo \u0026#34;$appname pid is : $pid\u0026#34; #判断进程是否存在，存在则kill、删除原程序目录、解压压缩包、启动程序 if [ -z $pid ]; then echo \u0026#34;$appname is not running!\u0026#34; echo \u0026#34;start rm /home/$appname\u0026#34; rm -rf /home/$appname echo \u0026#34;tar -zxf $appname-bin.tar.gz\u0026#34; #解压到指定目录 tar -zxf /home/$appname-bin.tar.gz -C /home echo \u0026#34;starting $appname....\u0026#34; #nohup启动应用，日志输出到对应目录 nohup java -jar /home/$appname/$appname.jar \u0026gt;/home/log/$appname.log 2\u0026gt;\u0026amp;1 \u0026amp; echo \u0026#34;start $appname success!\u0026#34; else echo \u0026#34;start kill $pid \u0026#34; kill -9 $pid echo \u0026#34;end kill $pid \u0026#34; echo \u0026#34;start check $appname ...... \u0026#34; #睡眠3秒防止进程kill延迟 sleep 3 #检查是否杀死进程，杀死则重新部署应用，失败退出 check=`ps -ef|grep -w $pid|grep java|awk \u0026#39;{printf $2}\u0026#39;` if [ -z $check ]; then echo \u0026#34;$appname:$pid is killed success!\u0026#34; echo \u0026#34;start rm /home/$appname\u0026#34; rm -rf /home/$appname echo \u0026#34;tar -zxf $appname-bin.tar.gz\u0026#34; tar -zxf /home/$appname-bin.tar.gz -C /home echo \u0026#34;starting $appname....\u0026#34; nohup java -jar /home/$appname/$appname.jar \u0026gt;/home/log/$appname.log 2\u0026gt;\u0026amp;1 \u0026amp; echo \u0026#34;start $appname success!\u0026#34; else echo \u0026#34;$appname stop failed !!!!\u0026#34; fi fi ","permalink":"https://zpc2222.github.io/posts/tech/shell-script/","summary":"shell启动脚本 1 2 java -Xms1024m -Xmx1024m -Xmn512m -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:7665 -jar oc-app-test.jar \u0026amp; java -jar-Dnet.java.games.input.librarypath=/home/oc/oc-app-test -Xdebug-Xrunjdwp:transport=dt_socket,suspend=n,server=y,address=*:7665/home/oc/oc-app-test/*.jar \u0026amp; nccloud启动脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/sh #根据端口号查询对应的pid #pid=$(netstat -nlp | grep :$port | awk \u0026#39;{print","title":"Shell脚本"},{"content":"windows命令 查看端口占用PID netstat -aon|findstr \u0026ldquo;9000\u0026rdquo;\n查看进程 tasklist|findstr \u0026ldquo;9088\u0026rdquo; 杀进程 taskkill /T /F /PID 9088\n","permalink":"https://zpc2222.github.io/posts/tech/windows/","summary":"windows命令 查看端口占用PID netstat -aon|findstr \u0026ldquo;9000\u0026rdquo; 查看进程 tasklist|findstr \u0026ldquo;9088\u0026rdquo; 杀进程 taskkill /T /F /PID 9088","title":"Windows"},{"content":"io简介 tag-placeholder\nIO 指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口 在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。\nAIO Java AIO即Async非阻塞，是异步非阻塞的IO。\nBIO Java BIO即Block I/O ， 同步并阻塞的IO。 BIO就是传统的java.io包下面的代码实现。\nNIO NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据 面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。\n一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。\n区别及联系 BIO （Blocking I/O）：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。\nNIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞I/O模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，NIO的做法是叫一个线程不断的轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。\nAIO （ Asynchronous I/O）：异步非阻塞I/O模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。\n各自适用场景 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。\nNIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。\nAIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持\n","permalink":"https://zpc2222.github.io/posts/tech/network-programming-io/","summary":"io简介 tag-placeholder IO 指计算机与外部世界或者一个程序与计算机的其余部分的之间的接口 在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的","title":"网络编程IO"},{"content":" 我的音乐歌单 音乐插件 写入后，根据id，server自行修改，网易云，QQ音乐，酷狗都支持；目前非会员已经无法白嫖听歌了，只能听免费歌曲\n1 2 3 4 5 6 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;aplayer\u0026#34; data-id=\u0026#34;2384590275\u0026#34; data-server=\u0026#34;tencent\u0026#34; data-type=\u0026#34;playlist\u0026#34; data-mode=\u0026#34;circulation\u0026#34; data-autopla=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 参数说明 主要参数 值 data-id 歌曲/专辑/歌单 ID data-server netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） data-type song （单曲） album （专辑） playlist （歌单） search （搜索） data-mode random （随机） single （单曲） circulation （列表循环） order （列表） data-autoplay false（手动播放） true（自动播放） 哔哩哔哩视频 写好了bilibili.html中，在markdown里嵌入视频的话，用以下形式写就ok了： \u003c!DOCTYPE HTML\u003e 如果需要指定part \u003c!DOCTYPE HTML\u003e ","permalink":"https://zpc2222.github.io/posts/blog/blog-music/","summary":"我的音乐歌单 音乐插件 写入后，根据id，server自行修改，网易云，QQ音乐，酷狗都支持；目前非会员已经无法白嫖听歌了，只能听免费歌曲 1 2 3","title":"音乐"},{"content":" 沸月月的博客 关注互联网以及分享IT软件开发经验的个人博客 👉友链格式 名称： 我的个人小站 网址： https://zpc2222.github.io 图标： https://zpc2222.github.io/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉广告位招租 ","permalink":"https://zpc2222.github.io/links/","summary":"沸月月的博客 关注互联网以及分享IT软件开发经验的个人博客 👉友链格式 名称： 我的个人小站 网址： https://zpc2222.github.io 图标： https://zpc2222.github.io/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友","title":"🤝友链"}]